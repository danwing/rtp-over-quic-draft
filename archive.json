{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-07-23T00:21:02.229034+00:00",
  "repo": "mengelbart/rtp-over-quic-draft",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "SDP",
      "description": "",
      "color": "528EC7"
    },
    {
      "name": "NextDoc",
      "description": "Potential additions in a next-generation document",
      "color": "bfdadc"
    },
    {
      "name": "NextInterim",
      "description": "Targeting discussion at next interim meeting",
      "color": "52B96A"
    },
    {
      "name": "NotJustRTP",
      "description": "Issue is not specific to RTP over QUIC",
      "color": "bfdadc"
    },
    {
      "name": "IETF117",
      "description": "Targeting discussion at IETF117",
      "color": "bfd4f2"
    },
    {
      "name": "Review outside AVTCORE needed",
      "description": "Issue relies on expertise outside WG core competence",
      "color": "5319e7"
    },
    {
      "name": "Not Yet",
      "description": "Text would depend on implementation/deployment experience",
      "color": "fbca04"
    }
  ],
  "issues": [
    {
      "number": 11,
      "id": "I_kwDOFUmh7s5KFI8X",
      "title": "RTCP and delay based CC in QUIC",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/11",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Section 6.1](https://datatracker.ietf.org/doc/html/draft-engelbart-rtp-over-quic#section-6.1) currently says that QUIC MUST use a timestamp extension to implement a delay-based congestion controller. Technically, the timestamps could also be implemented in RTCP using [RFC 8888](https://www.rfc-editor.org/rfc/rfc8888.html), but that would mean, that the application has to give timestamps back to the QUIC layer via some API. I am not sure if this is useful or if it would, for example, suffer from timing problems given that the arrival timestamp feedback would pass through the application layer before reaching the congestion controller at the transport layer.\r\n\r\nMaybe the document should give some guidance on what to do if no QUIC ack timestamps are available, e.g., \"RTCP MAY be used as a replacement\" or \"RTCP SHOULD NOT be used and instead CC option 2 (Section 6.2) SHOULD be used\".\r\n\r\nSee also the Editor's note in Section 6.1",
      "createdAt": "2022-05-20T09:14:13Z",
      "updatedAt": "2022-09-12T13:46:36Z",
      "closedAt": "2022-09-12T13:46:36Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOFUmh7s5MlxXl",
      "title": "State what endpoints should do if the QUIC datagram extension is not enabled",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/13",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "SDP",
        "NotJustRTP",
        "IETF117"
      ],
      "body": "The RTP over QUIC puts a hard requirement on endpoints advertising their support for the QUIC datagram extension.\r\n\r\nIf endpoints use ALPN to select RTP over QUIC, but the QUIC transport parameters do not contain a `max_datagram_frame_size`, it is not clear what should happen. One approach would be to fail the connection at the point this is detected, such as rejcting the connection handshake. \r\n\r\nNot stating an expected way to handle this could lead to some interop problems.",
      "createdAt": "2022-06-26T16:29:35Z",
      "updatedAt": "2023-05-17T16:38:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Datagram support in the QUIC implementation is only required if RTP over QUIC datagrams is required. If datagrams are not supported, endpoints can still use QUIC streams. Would it be helpful to add something like \"endpoints MUST not use datagrams unless support was indicated via `max_datagram_frame_size` by both endpoints\"?",
          "createdAt": "2022-06-27T10:32:05Z",
          "updatedAt": "2022-06-27T10:32:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "So I might be misunderstanding (and if so, let me know) but I don't think that requirement quite captures what your goals would be. When your peer doesn't support receiving QUIC datagrams you *can't* send them by definition of QUIC.\r\n\r\nThe quandry RTP over QUIC has is offering two ways to carry application data with little guidance on how applications would use these features. For example, if the client *only* wants to send datagrams and the server doesn't state it supports the QUIC datagram extension, what happens?\r\n\r\nEqually and oppositely, imagine a client only wants to use streams, and the server only wants to receive datagrams - so provides zero credits for creating streams. What happens?\r\n\r\nYou suggest QUIC streams can be used as a fallback from datagrams, but I think that highlights a design assumption in the specification, which could benefit from being made explicit. I'm not sure everybody is on board with that design if it isn't written down.\r\n\r\nSince you have two ways to carry data, and those capabilities are advertised unilaterally, you have a matrix of combinations. You might want to think about codifying these, so that applications can communicate their intent early. For instance, defining an RTP-over-QUIC transport parameter or a few ALPNs, to help negotiate the capabilities at the start.",
          "createdAt": "2022-06-27T10:47:00Z",
          "updatedAt": "2022-06-27T10:47:00Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think I misunderstood the issue. You're right, my suggestion doesn't make much sense, since using datagrams is already impossible when it is not supported.\r\n\r\nMaybe our assumption is, that since peers have to negotiate the session out of band, we expect them to negotiate only what their QUIC implementations support and then adhere to what they negotiated. But that probably doesn't really prevent the situations you describe.\r\n\r\nI think we might want to add some explanation about what we expect from the external signalling and then also add a transport parameter or different ALPNs as you suggested.\r\n\r\nI am thinking about how to implement this in the draft, but I am not (yet) sure if I understand all the implications. For example, the situation you describe, where a server provides zero credits for streams, wouldn't that still be possible, even with the correct signalling and is there anything we could do about it?",
          "createdAt": "2022-07-01T11:50:41Z",
          "updatedAt": "2022-07-01T11:50:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'm not an RTP expert so take my comments with a pinch of salt. But any time I hear that a signalling mechanism puts some expectations on a loosely coupled transport, I get a bit nervy. This is primarily because applications don't always have as tight a coupling (or control) over their transport layer as they think they might like. HTTP/3 has a bit of this now, where multi-cloud or multi-CDN deployments can invalidate prior advertisements.\r\n\r\nDesigning some robustness into handling mismatches can help spot them earlier. Transport parameters or ALPNs have different tradeoffs. I wouldn't rush into picking one without understanding your problem space. So this issue might need some time to mature.\r\n\r\nYou're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance. ",
          "createdAt": "2022-07-02T23:55:33Z",
          "updatedAt": "2022-07-02T23:55:33Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion with @joerg-ott and @mengelbart, I think this comment from @LPardue is an excellent place to start ... \r\n\r\n> You're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance.\r\n\r\nWhat I'm thinking, is that we can reasonably say \r\n1. If both sides don't support datagrams/provides zero credits for datagrams, you won't be using datagrams (duh), \r\n2. So you're going to be using streams, and we can make suggestions that will help this \"suck less\". \r\n\r\nI can propose text for this, at least as a starting point. I'm not tagging the issue as a pre-IETF 116 priority for now. \r\n\r\nDoes that all make sense?",
          "createdAt": "2023-01-13T16:43:02Z",
          "updatedAt": "2023-01-13T16:46:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Issue #76 adding error codes will help with this one. ",
          "createdAt": "2023-05-17T16:37:15Z",
          "updatedAt": "2023-05-17T16:37:15Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOFUmh7s5Mlx2F",
      "title": "What stream types are used?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/14",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "QUIC provides 4 stream types, the spec seems to overlook stating if there are any requirements on the use of these streams. An application needs to know the right type to pick for interop.\r\n\r\nIn the simplest case, I can imagine that a single RTP packet is sent on a unidirectional stream, which is then closed. But perhaps you picture a bidirectional stream being used to exchange a pair of packets?",
      "createdAt": "2022-06-26T16:37:40Z",
      "updatedAt": "2022-09-23T07:18:16Z",
      "closedAt": "2022-09-23T07:18:16Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I agree, we should clarify that in the spec. I also realized that we don't state explicitly, that a stream MUST be closed immediately after the RTP packet is completely sent, otherwise streams don't work as implicit framing. I think we just assumed unidirectional streams because we expect senders to close streams after sending a packet. I think technically it might be possible to use bidirectional streams, too, but since there is no synchronous relationship between sent and received RTP/RTCP packets, it is probably easier to use unidirectional streams.\r\n\r\nI just opened #17 for this.",
          "createdAt": "2022-06-27T13:49:56Z",
          "updatedAt": "2022-06-27T13:49:56Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOFUmh7s5Mlx9R",
      "title": "Missing considerations about stream concurrecy",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/15",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When RTP packets are sent on streams, the spec only allows one packet per stream send side. This immediately limits the number of concurrent packets to be bound by the number of concurrent streams. \r\n\r\nI don't know which stream types you picture using (see #14) but that is tangential. Whatever types are used, the spec should give some consideration to the minumum and maximum number of concurrent streams for RTP over QUIC. Applications that fail to provide enough concurrency credit can cause deadlocks or timeouts.",
      "createdAt": "2022-06-26T16:39:53Z",
      "updatedAt": "2022-10-24T14:28:42Z",
      "closedAt": "2022-10-24T14:28:42Z",
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOFUmh7s5MlyFM",
      "title": "Does RTP over datagram retransmission happen on the same flow ID?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/16",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See https://www.ietf.org/archive/id/draft-engelbart-rtp-over-quic-04.html#section-6.2\r\n\r\nIt would seem to be sensible to recommend retransmitting the RTP packet on the same datagram flow ID but I'm not an expert on RTP stuff.",
      "createdAt": "2022-06-26T16:42:12Z",
      "updatedAt": "2022-09-12T13:54:24Z",
      "closedAt": "2022-09-12T13:54:24Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think it would depend on how the RTP implementation is doing retransmissions. RFC 4588 allows retransmissions either in the same session with a different SSRC or in a separate session. If different flow IDs are required for different sessions, as is the case in the current draft, then that would also be the case for retransmissions in different sessions, but not for retransmissions that happen in the same session.",
          "createdAt": "2022-06-27T10:55:58Z",
          "updatedAt": "2022-06-27T10:55:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "That sounds reasonable. Since it sounds like there are some implementation decisions to make, It might be helpful to note that this type of retransmission behaviour is possible, and what the implications are for both stream-based or datagram-based retransmissions. ",
          "createdAt": "2022-06-27T11:07:40Z",
          "updatedAt": "2022-06-27T11:07:40Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOFUmh7s5PDxu-",
      "title": "Section 8: Bandwidth sharing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/20",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"*TODO:* Add considerations for bandwidth shares when a QUIC connection is shared between RTP and non-RTP streams?\"",
      "createdAt": "2022-08-02T20:54:03Z",
      "updatedAt": "2022-09-12T13:45:29Z",
      "closedAt": "2022-09-12T13:45:29Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This was done by adding [section 8.3](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#name-shared-quic-connections) but I forgot to remove the TODO. I will create a PR.",
          "createdAt": "2022-08-03T07:46:57Z",
          "updatedAt": "2022-08-03T07:46:57Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOFUmh7s5PDzWj",
      "title": "Section 8.1: Congestion control recommendations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/21",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"  If congestion control is to be applied at the transport layer, it is\r\n   RECOMMENDED to configure the QUIC Implementation to use a delay-based\r\n   real-time congestion control algorithm instead of a loss-based\r\n   algorithm.  The currently available delay-based congestion control\r\n   algorithms depend on detailed arrival time feedback to estimate the\r\n   current one-way delay between sender and receiver. \"\r\n\r\n[BA] Can we make this a bit more specific? \r\n\r\n1. By \"delay-based congestion control algorithms\" are you referring to the algorithms mentioned in RFC 8888 Section 1?\r\n2. Would BBRv2 qualify?\r\n3. Mac OS X 16 includes support for L4S and scalable congestion control.  Would this qualify? \r\nSee: https://developer.apple.com/videos/play/wwdc2022/10078/\r\n\r\n",
      "createdAt": "2022-08-02T21:02:07Z",
      "updatedAt": "2022-10-24T14:41:47Z",
      "closedAt": "2022-10-24T14:41:47Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> [BA] Can we make this a bit more specific?\r\n> \r\n>     1. By \"delay-based congestion control algorithms\" are you referring to the algorithms mentioned in RFC 8888 Section 1?\r\n\r\nI think that was the intention when we wrote this paragraph. When thinking about this again now, I think it may be better to express this recommendation by explaining the application's requirements rather than by the congestion signals used by the employed algorithm or even listing specific ones. If we do that, it would also make sense to relax the following sentences:\r\n\r\n> The currently available delay-based congestion control algorithms depend on detailed arrival time feedback to estimate the current one-way delay between sender and receiver. Since QUIC does not provide arrival timestamps in its acknowledgments, the QUIC implementations of the sender and receiver MUST use an extension to add this information to QUICs acknowledgment frames\"\r\n\r\nIf we don't specify how the algorithms should work internally, it also doesn't make sense to require the use of a timestamp extension to provide one-way delay measurements.\r\n\r\n>     2. Would BBRv2 qualify?\r\n> \r\n>     3. Mac OS X 16 includes support for L4S and scalable congestion control.  Would this qualify?\r\n>        See: https://developer.apple.com/videos/play/wwdc2022/10078/\r\n\r\nWould it be specific enough to express a need for a congestion controller that ensures that RTP/RTCP packets are transmitted at low latencies? I think that would exclude loss-based algorithms and may exclude BBRv1 due to probing. I don't know if BBRv2 would qualify and I think L4S would.",
          "createdAt": "2022-08-03T08:48:17Z",
          "updatedAt": "2022-08-03T08:49:12Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I like the idea of specifying the general requirement (e.g. low-latency).  Separately, it would be worth understanding whether QUIC cc algorithms meet that requirement (e.g. whether BBRv2 is usable or not, whether iOS 16 L4S is helpful, etc.). ",
          "createdAt": "2022-08-03T14:35:59Z",
          "updatedAt": "2022-08-03T14:35:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I opened #36. I agree that it would be worth understanding which algorithms meet the requirement, but since I can currently not answer that for algorithms like BBRv2 or L4S, I don't want to put my assumptions in the document.",
          "createdAt": "2022-09-12T15:43:59Z",
          "updatedAt": "2022-09-12T15:43:59Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOFUmh7s5PD1SK",
      "title": "Section 8.1: QUIC connection sharing with non-RTP streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/22",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's note:* How can a QUIC connection be shared with non-RTP\r\n      streams, when SCReAM/NADA/GCC is used as congestion controller?\r\n      Can these algorithms be adapted to allow different streams\r\n      including non-real-time streams?  Do they even have to be adapted\r\n      or _should_ this just work?\r\n\r\n[BA] When a file is being transferred within an audio/video chat session, it is typically desired for the file transfer not to interfere with media. To accomplish this, the file transfer is subjected to the same low-latency cc algorithm and also, the bandwidth allocated to the transfer may be restricted. Subjecting the transfer to unified congestion control means that it will take longer that it would if it were on a separate connection competing with the A/V traffic, but that's the desired outcome.",
      "createdAt": "2022-08-02T21:11:41Z",
      "updatedAt": "2022-09-12T13:51:07Z",
      "closedAt": "2022-09-12T13:51:06Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "That makes sense, I think we can delete the note.",
          "createdAt": "2022-08-04T17:06:09Z",
          "updatedAt": "2022-08-04T17:06:09Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOFUmh7s5PD1jA",
      "title": "Section 8.1: Timestamp extension requirement",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/23",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's note:* An alternative to the hard requirement to use a\r\n      timestamp extension could be to use RTCP, but that would mean,\r\n      that an application has to negotiate RTCP congestion control\r\n      feedback which would then have to be passed to the QUIC congestion\r\n      controller.",
      "createdAt": "2022-08-02T21:13:06Z",
      "updatedAt": "2022-09-12T13:46:36Z",
      "closedAt": "2022-09-12T13:46:36Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "See also #11 \r\n\r\n[Section 7](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#name-rtcp) explains in detail how information from the QUIC layer can be used to replace RTCP. This is the opposite: we want to use information from RTCP at the QUIC layer. I don't think is useful to add text for this to the document for the following reasons:\r\n\r\n- The QUIC congestion controller would depend on the information that is only present at the application layer. If we want to use RTCP (e.g., because timestamps are not available), we can still have congestion control at the application layer as explained in [section 8.2](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#section-8.2). If there's no API to disable/manage the QUIC congestion controller, there will likely be no API to pass feedback to it either.\r\n- It would be unclear how the QUIC congestion controller should treat non-RTP data for which we still don't have arrival times.\r\n\r\nShould we add an explanation for these problems or just delete the note?",
          "createdAt": "2022-08-03T09:04:36Z",
          "updatedAt": "2022-08-03T09:04:36Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I'd delete the note. ",
          "createdAt": "2022-08-03T14:20:15Z",
          "updatedAt": "2022-08-03T14:20:15Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOFUmh7s5PD41X",
      "title": "Section 6: Multiplexing of non-RTP/RTCP data streams and datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/24",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "\"  For multiplexing different RTP and other data streams on the same\r\n   QUIC connection, each RTP/RTCP packet is prefixed with a flow\r\n   identifier.  A flow identifier is a QUIC variable-length integer\r\n   which must be unique per stream...\r\n\r\n   Differentiating RTP/RTCP packets of different RTP sessions from non-\r\n   RTP/RTCP datagrams is the responsibility of the application by means\r\n   of appropriate use of flow identifiers and the corresponding\r\n   signaling.\"\r\n\r\n[BA] This text is a bit vague with respect to setup of non-RTP/RTCP data streams and datagrams.\r\n\r\nAs an example, in WebRTC it is possible to [create additional data channels without signaling](https://w3c.github.io/webrtc-pc/#rtcdatachannel). \r\n\r\nHow would equivalent functionality be supported in RTP over QUIC? For example, one might assume that the desire to exchange data is negotiated, but once done, that a non-RTP/RTCP data stream or datagrams could then be received.  How are these non-RTP/RTCP data streams or datagrams distinguished from RTP/RTCP?  Do we examine the first octet as per RFC 7983bis or is some other multiplexing mechanism used? ",
      "createdAt": "2022-08-02T21:30:21Z",
      "updatedAt": "2023-01-18T16:22:10Z",
      "closedAt": "2023-01-18T16:22:09Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Initially, the idea was to require the flow identifier in every datagram sent on the QUIC connection, allowing the receiver to demultiplex based on the flow identifier. However, that may require some signaling to map flow identifiers to protocols, and as you rightly point out, it may be desired to open new channels without additional signaling, and the flow identifier could also conflict with other protocol mappings to QUIC streams/datagrams.\r\n\r\nI think this is also related to #31. Depending on what ALPN we define in this document and which combinations of protocols this ALPN includes, we may have different multiplexing requirements.\r\n\r\nThe easiest case would probably be an ALPN like \"rtp-quic\" that identifies RTP over QUIC without multiplexing additional non-RTP/RTCP protocols. In that case, we could rely on traditional multiplexing mechanisms for RTP/RTCP, such as RFC 5761 for multiplexing RTP and RTCP or RFC 8860 for sending multiple types of media in a single RTP session. However, I think both RFCs have some limitations that a flow identifier could potentially solve at the cost of some bytes.\r\n\r\nMultiplexing RTP/RTCP and other protocols will be more complicated. One solution could be RFC 7983bis. RFC 7983bis may not work if RTP/RTCP packets are prepended with a flow identifier, which may be solved by prepending the flow identifier with another byte that takes a value that does not yet match any other protocol in RFC 7983bis. But I am not sure if RFC 7983bis is what we need here, given that something like data channels could run directly in QUIC and would not necessarily need to be encapsulated in SCTP/DTLS over QUIC.\r\n\r\nIf we leave multiplexing of multiple protocols to future documents with a separate ALPN in #31, we could also leave the specifics of how the multiplexing works to those documents. In that case, it might be valuable to add a *Multiplexing Guidelines* section to this document.",
          "createdAt": "2022-09-19T14:39:56Z",
          "updatedAt": "2022-09-19T14:39:56Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Resolved in #54 ",
          "createdAt": "2023-01-18T16:22:09Z",
          "updatedAt": "2023-01-18T16:22:09Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOFUmh7s5PD5ch",
      "title": "Section 6.1: RTP topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/25",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's Note:* Note, however, that using a single frame per\r\n      stream in a single RTP packet may cause interworking issues when a\r\n      translator wants to forward packets received via RTP-over-QUIC to\r\n      an endpoint as UDP packets because the received ADUs may exceed\r\n      the MTU size or even maximum UDP packet size.\r\n\r\n[BA] This (and other aspects, such as lack of multicast support) has implications for the [supportable RTP topologies](https://datatracker.ietf.org/doc/html/rfc7667). There is also the issue of RTCP interworking. Are there specific topologies that are not supported for use with RTP over QUIC? ",
      "createdAt": "2022-08-02T21:33:54Z",
      "updatedAt": "2022-10-24T15:26:29Z",
      "closedAt": "2022-10-24T15:26:29Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The introduction currently limits RTP over QUIC to unicast topologies:\r\n\r\n> The scope of this document is limited to unicast RTP/RTCP.\r\n\r\nWe may need to re-evaluate multicast topologies if [QUIC multicast](https://datatracker.ietf.org/doc/draft-jholland-quic-multicast/) becomes available.\r\n\r\nI think most of the non-multicast topologies should be supportable with a few constraints. Whenever a middlebox like a translator needs access to the RTP packet, the QUIC connection must be terminated at the middlebox. I think RTP over QUIC can also support the case described in the note if the translator can rewrite the RTP packets to smaller ones.\r\n\r\nShould we add a new section to explain these limitations?",
          "createdAt": "2022-09-20T08:13:18Z",
          "updatedAt": "2022-09-20T08:13:18Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Adding a section to explain the limitations would make sense. \r\n\r\nHaving a middlebox packetizing frames is complex, because RTP packetization is codec-specific.  Some MANEs do this today (e.g. in order to adjust to MTU differences), but typically those MANEs only support a single codec. ",
          "createdAt": "2022-09-20T18:56:41Z",
          "updatedAt": "2022-09-20T18:56:41Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOFUmh7s5PD7AB",
      "title": "Section 9.2: Disabling QUIC Congestion Control",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/26",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "   *  _Disable Congestion Controller_: If congestion control is to be\r\n      implemented at the application layer as described in Section 8.2,\r\n      and the application layer is trusted to apply adequate congestion\r\n      control, it is RECOMMENDED to allow the application to disable QUIC\r\n      layer congestion control entirely.\r\n\r\n[BA] In terms of the overall requirements, you might cite RFC 9002 Section 7, which says: \r\n\r\n\"If a sender uses a different controller than that specified in this\r\n   document, the chosen controller MUST conform to the congestion\r\n   control guidelines specified in [Section 3.1 of [RFC8085]](https://datatracker.ietf.org/doc/html/rfc8085#section-3.1).\"",
      "createdAt": "2022-08-02T21:42:31Z",
      "updatedAt": "2022-09-23T07:19:09Z",
      "closedAt": "2022-09-23T07:19:09Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOFUmh7s5PD77e",
      "title": "Section 9.2: Choosing an appropriate congestion control algorithm",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/27",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"   *  _Select Congestion Controller_: If congestion control is to be\r\n      implemented at the QUIC connection layer as described in\r\n      Section 8.1, the application must be able to choose an appropriate\r\n      congestion control algorithm.\"\r\n\r\n[BA] Is the need to choose an appropriate algorithm, or to be able to provide information on what characteristics are desired? \r\nRelated: https://github.com/w3c/webtransport/issues/365",
      "createdAt": "2022-08-02T21:47:52Z",
      "updatedAt": "2022-10-24T15:00:35Z",
      "closedAt": "2022-10-24T15:00:35Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "If we decide to state the characteristics in section 8.1 instead of specific algorithms, as discussed in #21 and #36, I think we can leave it to the implementation to decide what the concrete API should look like. I think some QUIC implementations allow choosing between algorithms, but I could also imagine an implementation that lets the application provide information that the QUIC implementation can use to make a decision. Maybe we can change the wording to something like this:\r\n\r\n```\r\nIf congestion control is to be implemented at the QUIC connection (layer as\r\ndescribed in Section 8.1), the QUIC implementation SHOULD expose an API to\r\nconfigure the congestion control algorithm.\r\n```",
          "createdAt": "2022-09-12T16:10:54Z",
          "updatedAt": "2022-09-12T16:10:54Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "In WebTransport, the approach taken has been to provide a \"hint\" to the QUIC stack which would allow it to select an appropriate congestion control algorithm.  There is no implementation of this yet.  That approach was selected over more detailed configuration of the congestion control algorithm. ",
          "createdAt": "2022-09-20T18:52:31Z",
          "updatedAt": "2022-09-20T18:52:31Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think that makes sense for WebTransport, but I am not sure we need to be specific about this here. For example, a QUIC implementation that only offers a low latency congestion controller would be fine, even if it does not provide any configuration options to the application. It may be more useful not to phrase this as what the application can control, but rather as how the QUIC implementation must do congestion control.",
          "createdAt": "2022-09-29T10:44:11Z",
          "updatedAt": "2022-09-29T10:44:11Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOFUmh7s5PImlZ",
      "title": "SFrame/SPacket",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/29",
      "state": "OPEN",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "NotJustRTP"
      ],
      "body": "The spec does not currently describe how [SFrame](https://datatracker.ietf.org/doc/draft-ietf-sframe-enc/) is supported in RTP over QUIC, or what an RTP translator should do. One way to address this would be to add a section that would deal with the issues that come up when implementing [SFrame](https://datatracker.ietf.org/doc/draft-ietf-sframe-enc/) in RTP over QUIC.",
      "createdAt": "2022-08-03T18:56:51Z",
      "updatedAt": "2023-03-20T16:47:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I may be missing some background on SFrame/SPacket, but as far as I understand the document you linked, SFrame tries to be independent of the underlying transport, so I don't understand why the RTP over QUIC document should cover its usage. Could you explain why SFrame should only be used with QUIC streams and SPacket only in QUIC datagrams?",
          "createdAt": "2022-09-19T10:41:40Z",
          "updatedAt": "2022-09-19T10:41:40Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "SFrame encrypts an entire frame, making it opaque.\r\n\r\nThis creates problems for an RTP translator.  Since the RTP translator cannot know what is inside the SFrame (since it typically will not have access to the encryption key), it cannot re-packetize the SFrame in a codec-specific way.  This problem can arise if the SFrame is transported using RTP over a reliable QUIC stream and it is desired to translate to RTP over UDP.",
          "createdAt": "2022-09-20T18:48:53Z",
          "updatedAt": "2022-11-07T01:28:30Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> if the SFrame doesn't need to be packetized (e.g. it is put into a QUIC stream) this is not an issue.\r\n\r\nThe frame would still be packetized in RTP packets in both QUIC datagrams and streams. The RTP packet size in a QUIC stream may be much larger (containing the entire frame instead of just one fragment), and each stream can only be used for one RTP packet.\r\n\r\nIf I understand it correctly, RTP over QUIC (Datagrams and Streams) would have the same support (and issues) for SFrame/SPacket as RTP over UDP?",
          "createdAt": "2022-09-21T11:37:55Z",
          "updatedAt": "2022-09-21T11:37:55Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "There are issues with the implementation of RTP translation between RTP over QUIC and RTP/UDP, regardless of whether RTP over QUIC uses QUIC reliable streams or datagrams: \r\n\r\n1. When RTP over QUIC is transported in a QUIC reliable stream, the MTU size is much larger than the RTP over UDP MTU.  So the RTP/QUIC payload needs to be re-packetized to be sent over RTP/UDP. \r\n\r\n2. When RTP/UDP is translated to RTP over QUIC datagrams, there can also be a re-packetization issue. If the UDP MTU is larger than the QUIC datagram MTU, then re-packetization would be required or else oversize RTP over QUIC datagrams would be fragmented. \r\n\r\nSFrame complicates these issues further since the RTP payloads are opaque, and are thus not amenable to codec-specific re-packetization. ",
          "createdAt": "2022-11-07T01:33:25Z",
          "updatedAt": "2022-11-07T01:34:43Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Related: https://github.com/pthatcher/sframe-over-rtp-over-quic-draft/blob/main/draft-pthatcher-sframe-over-rtp-over-quic.txt",
          "createdAt": "2022-11-07T01:38:12Z",
          "updatedAt": "2022-11-07T01:38:12Z"
        },
        {
          "author": "pthatcher",
          "authorAssociation": "NONE",
          "body": "I tried to explain the issue in the draft I wrote to solve this. \r\n\r\nThe gist is that the problem is when a translator has larger RTP packets on one side smaller RTP packets on the other.   QUIC streams allow for very large RTP packets, and the translator has to deal with that.  The RTP-over-QUIC document says that the solution is to use \"codec-specific packetization\", but when SFrame encrypts the codec, it effectively becomes the codec, so you need, basically, an SFrame-specific way to repacketize a large RTP packet containing SFrame into smaller RTP packets containing SFrame.   SPacket doesn't help because we're talking about large RTP packets, and SPackets will still have the same problem.  \r\n\r\nSo what I wrote in the draft Bernard just linked to is a mechanism to repacketize a large RTP packet containing SFrame (or SPacket; that works too) into smaller RTP packets containing SFrame (or SPacket).\r\n\r\nIt also discusses and supports the other direction: turning many smaller RTP packets back into one large RTP packet (translating the other way).",
          "createdAt": "2022-11-07T14:43:17Z",
          "updatedAt": "2022-11-07T14:43:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @pthatcher, @mengelbart and I think this question is being handled as generic for RTP, not for RTP-over-QUIC, and the relevant Githubs (draft-pthatcher-sframe-over-rtp-over-quic and draft-codec-agnostic-rtp-payload-format) are where this will be worked out. Is that also your understanding? ",
          "createdAt": "2023-03-09T16:42:28Z",
          "updatedAt": "2023-03-09T16:42:28Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOFUmh7s5PLdfS",
      "title": "ALPN for sharing a connection between RTP/RTCP and other protocols",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/31",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "SDP",
        "IETF116"
      ],
      "body": "One of the advantages of RTP over QUIC is the possibility to multiplex different protocols on the same connection. A simple use case for this is to share a single QUIC connection between a media session using RTP and some non-RTP data transfer, similar to WebRTC Data Channels. *draft-ietf-avtcore-rtp-over-quic* specifies a minimal application usage of QUIC for RTP. The draft defines an ALPN token (\u201crtp-mux-quic\u201d) because QUIC requires the usage of a mechanism to agree on an application layer protocol, and ALPN is the currently specified way of doing this using TLS. Other application usages of QUIC will have to define their own ALPN token, which implies that they must use a different QUIC connection from RTP over QUIC.\r\n\r\nWe currently see two possible ways to allow usage of RTP and other protocols multiplexed on the same QUIC connection:\r\n\r\n* Define a generic ALPN (e.g. \u201crtp-mux-sdp\u201d), which indicates that the application protocols to be carried in this connection are to be negotiated out of band (SDP). The problem with this approach is that we cannot define the actual multiplexing of the two protocols.\r\n* Explicitly state in the RTP over QUIC draft that future documents are allowed to define new ALPNs that identify protocols for multiplexing RTP over QUIC with other protocols. For example, an ALPN \u201crtp-mux-h3\u201d could be defined in a document that defines how RTP and HTTP/3 can be multiplexed in one QUIC connection. This document could reference the RTP over QUIC document but would have to explain how to multiplex the different protocols.\r\n\r\nOf course, these two options are not mutually exclusive.",
      "createdAt": "2022-08-04T10:20:26Z",
      "updatedAt": "2023-01-18T16:24:02Z",
      "closedAt": "2023-01-18T16:24:01Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "For an example of how this can be handled, see [RFC 8833](https://www.rfc-editor.org/rfc/rfc8833.html), which defines the ALPN registration for WebRTC.  The document defines two ALPNs, each of which supports multiplexing of both data and media. At no point does the document mention SDP. Looking at that document, something simple like \"rtp-mux-quic\" might be fine.\r\n\r\nMultiplexing of RTP-over-QUIC and HTTP/3 would be quite a complex exercise, because this would pull in interactions with HTTP/3 pooling, where multiple applications can interact.  As you've noted, RTP-over-QUIC has unique congestion control requirements which QUIC implementations used with HTTP/3 might not comply with (e.g. BBRv1). ",
          "createdAt": "2022-08-05T18:35:06Z",
          "updatedAt": "2022-08-05T18:35:06Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think RFC 8833 would be an example of the second option, where a separate document defines an ALPN for multiplexing two protocols. I agree HTTP/3 might be very complex and there are better examples that may be easier to define and possibly more useful. I assume we still need an ALPN in the RTP over QUIC document (e.g., \"rtp-quic\"), that can be used to exclusively send RTP and some other document could define an ALPN \"rtp-mux-quic\", for multiplexing RTP and something like data channels.",
          "createdAt": "2022-08-06T22:05:34Z",
          "updatedAt": "2022-08-06T22:05:34Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Not sure you'd need multiple ALPNs here. As an example, applications using WebTransport do not need a separate ALPN for each use case.  Similarly, WebRTC was able to use a single ALPN for both data and media by leveraging RFC 7983. ",
          "createdAt": "2022-09-20T18:40:52Z",
          "updatedAt": "2022-09-20T18:40:52Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think leveraging RFC 7983bis could work, but I am not sure it is what we need. WebRTC uses DTLS/SCTP for data, both of which *I think* we do not need on top of QUIC. But that leaves the question of what protocol will be used on top of QUIC to carry data instead. That's why I thought we could just define one ALPN (\"rtp-quic\") now and maybe later add one or more ALPNs for multiplexing RTP/RTCP and some other (data) protocols on top of QUIC. We could then also define the actual multiplexing similar to RFC 7983.\r\n\r\nI don't think we want to assign an ALPN now that allows multiplexing RTP/RTCP and any other unspecified protocol in the future because it would be unclear how to do the multiplexing.",
          "createdAt": "2022-09-21T08:44:12Z",
          "updatedAt": "2022-09-21T08:44:12Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "#54 solves the multiplexing issue using flow identifiers, which works with the ALPN currently defined in the document.",
          "createdAt": "2023-01-18T16:24:01Z",
          "updatedAt": "2023-01-18T16:24:01Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOFUmh7s5RqgMO",
      "title": "Add current bandwidth estimation to API considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/35",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Section 8.1](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#section-8.1) explains:\r\n\r\n> If congestion control is done by the QUIC implementation, the application needs a mechanism to query the currently available bandwidth to adapt media codec configurations. The employed congestion controller of the QUIC connection SHOULD expose such an API to the application.\r\n\r\nbut the API considerations in [Section 9.1](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#section-9.1) do not include such an API.",
      "createdAt": "2022-09-12T15:25:38Z",
      "updatedAt": "2022-09-22T08:50:13Z",
      "closedAt": "2022-09-22T08:50:13Z",
      "comments": []
    },
    {
      "number": 39,
      "id": "I_kwDOFUmh7s5SPx3a",
      "title": "Length field",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/39",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's Note:* We considered adding a framing like the one\r\n      described in [RFC4571] to send multiple RTP packets on one stream,\r\n      but we don't think it is worth the additional overhead only to\r\n      reduce the number of streams.  Moreover, putting multiple ADUs\r\n      into a single stream would also require defining policies when to\r\n      use the same (and which) stream and when to open a new one.\r\n\r\n[BA] The Length field isn't just for sending multiple RTP packets on one stream.  If the sender implements partial reliability, it may set a timer and then send a RESET_STREAM frame if the timer expires, in order to ensure against excessive retransmissions.  In that case, the receiver may only receive a portion of the frame, and the length field can enable it to determine that the frame was not completely received and should be discarded.  Also, the length field can be useful in memory allocation (e.g. a buffer can be allocated based on the expected length). \r\n\r\nI would also note that the 16-bit length defined in RFC 4571 was designed to be large enough to cover RTP packets, not entire frames sent in RTP over QUIC streams.  So if a length field is to be used in RTP over QUIC, it would either need to be larger (e.g. 32 bits) or if kept at 16 bits, could be used to denote the length in units of 4 octets.  ",
      "createdAt": "2022-09-20T19:04:35Z",
      "updatedAt": "2022-10-24T15:16:14Z",
      "closedAt": "2022-10-24T15:16:14Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "RESET_STREAM frames contain the final size of the stream, so the receiver can determine if the frame was completely received or not. But a length field may be helpful for the receiver to calculate how much data is still missing and to determine whether it is worth waiting longer before sending a STOP_SENDING frame.\r\n\r\nAn alternative for the 16-bit length field could also be to use a [variable-length integer](https://www.rfc-editor.org/rfc/rfc9000.html#section-16) as we did for the flow ID.",
          "createdAt": "2022-09-21T07:52:48Z",
          "updatedAt": "2022-09-21T07:52:48Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I just realized that the final size contained in a RESET_STREAM frame is not the size of the frame, but the\r\n\r\n> amount of flow control credit that is consumed by a stream\r\n\r\n[Section 4.5 of RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#section-4.5), so the receiver cannot use it to determine if a frame was completely received or not.\r\n\r\nSorry for the confusion.",
          "createdAt": "2022-09-23T08:25:49Z",
          "updatedAt": "2022-09-23T08:25:49Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I added the length field in #43 ",
          "createdAt": "2022-10-24T15:16:14Z",
          "updatedAt": "2022-10-24T15:16:14Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "I_kwDOFUmh7s5Sdo7k",
      "title": "Consider allowing mixing of QUIC streams and datagrams within RTP sessions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/41",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "> This specification defines two ways of carrying RTP packets in QUIC: 1) using reliable QUIC streams and 2) using unreliable QUIC DATAGRAMs. Every RTP session MUST choose exactly one way of carrying RTP and RTCP packets, different RTP sessions MAY choose different ways\r\n\r\nThe restriction to choosing exactly one way of carrying packets was added to avoid any unexpected outcomes of sending some RTP packets reliably on QUIC streams and others unreliably in QUIC datagrams.\r\n\r\nIt may however be desired to allow mixing streams and datagrams to implement partial reliability. For example, a sender may want to send I-frames of a video stream in QUIC streams to ensure reliable delivery, while sending P-frames in datagrams. Another scenario might be to send base layers of a stream using scalable video in QUIC streams and any additional layers in QUIC datagrams.",
      "createdAt": "2022-09-23T09:02:45Z",
      "updatedAt": "2022-10-24T14:30:04Z",
      "closedAt": "2022-10-24T14:30:04Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "As you mention, there are several use cases for using both QUIC streams and datagrams. \r\n\r\nWith SVC, base layer packets may represent a minority of the packets sent (as little as 25 percent with L1T3).  Since the base layer packets depend on each other, and losing one may prevent decoding of subsequent frames at all layers, losing a base layer frame has a high cost (e.g. keyframe generation).  \r\n\r\nTo avoid this cost, it may be necessary to set partial reliability timers considerably higher for base layer frames than for \"discardable\" extension layers.  In such a situation, sending base layer frames via frame/stream may not be that different from sending base layer frames over a single unidirectional stream. \r\n",
          "createdAt": "2022-10-04T03:04:34Z",
          "updatedAt": "2022-10-04T03:04:34Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I will bring this up in the meeting today. My general impression is that it is something that we should support. We were hesitant about this in the beginning because we were unsure of the potential problems this could bring up. When experimenting with this setup I ran into a synchronization issue where P-frames arrived before the first I-frame because the implementation prioritized sending datagrams first. This is solvable by having a jitter buffer wait for the first I-frame before passing anything to a decoder, but there may be other problems we haven't thought of yet.\r\n\r\n> To avoid this cost, it may be necessary to set partial reliability timers considerably higher for base layer frames than for \"discardable\" extension layers. In such a situation, sending base layer frames via frame/stream may not be that different from sending base layer frames over a single unidirectional stream.\r\n\r\nI think allowing multiple frames/ADUs per frame may be a follow-up discussion of #39?",
          "createdAt": "2022-10-04T08:43:29Z",
          "updatedAt": "2022-10-04T08:43:29Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOFUmh7s5TPau_",
      "title": "Interoperability between RTP over QUIC streams and plain RTP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/42",
      "state": "CLOSED",
      "author": "murillo128",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If I understood the draft correctly, basically when sending a frame with RTP over QUIC using streams, it will be \"packetized\" considering the MTU being infinite, that is, the whole frame would be sent as payload of the RTP packet (while still adhering to RTP packetization rules, I assume).\r\n\r\nThis would cause issues when trying to do a gateway that bridges between \"normal\" RTP and the QUIC stream version, as it will have to packetize/depacketize the whole frame again.\r\n\r\nOne potential solution is to still generate multiple RTP packets per frame and send them using RFC4571 over a single QUIC stream:\r\n\r\n```\r\n|len 1|RTP Packet1|len 2|RTP Packet2|...|len n|RTP PacketN|\r\n```\r\n\r\nThis would solve the interoperability issues, although will have a higher bandwdith overhead. ",
      "createdAt": "2022-10-04T16:30:12Z",
      "updatedAt": "2022-10-26T05:14:12Z",
      "closedAt": "2022-10-24T15:35:27Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I believe there are two sets of interop issues: \r\n\r\n1. - Interop between RTP over QUIC datagrams and RTP over UDP\r\n2. - Interop between RTP over QUIC frame/stream transport and RTP over UDP\r\n\r\nMTU issues can arise in either case. For example, RTP over QUIC datagrams may have a smaller MTU than RTP over UDP so RTP/UDP packets might need to be repacketized into multiple RTP/QUIC datagrams. \r\n\r\nTo enable a translator to operate without repacketization (which could require codec-specific knowledge), the RTP/UDP MTU needs to be set smaller, so as to allow the translated RTP/QUIC datagrams to stay within the MTU. \r\n\r\nSimilarly, RTP/QUIC stream transport could be configured with a non-infinite MTU, so as to allow a translator to translate to RTP/UDP without repacketizing.",
          "createdAt": "2022-10-15T22:35:16Z",
          "updatedAt": "2022-10-15T22:35:16Z"
        },
        {
          "author": "murillo128",
          "authorAssociation": "NONE",
          "body": "What is QUIC datagram overhead? i doubt #1 will ever be an issue in real life, while i doubt that QUIC over stream will be configured for non-infinite MTU as it defeat the whole pourpose of using streams.",
          "createdAt": "2022-10-15T23:50:26Z",
          "updatedAt": "2022-10-15T23:50:26Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "The RTP Topologies section is there to describe topologies, issues and potential solutions.  The topologies include use cases such as conferencing where the SFU and browser clients could be designed to work together. \r\n\r\nIn a use case where the conferencing server wants to support both RTP over QUIC and RTP/UDP clients, how can this be accomplished? In such a use case, the topology section needs to think about not only what a client should send, but also what it would need to be able to receive. \r\n\r\nIf the conferencing server is an SFU and is willing to parse the payload, it can re-packetize from RTP over QUIC streams to RTP/UDP.  But it may not want to do this.  For example, if the SFU wants to support multiple codecs (e.g. VP8, VP9, H.264, AV1) it might want to handle forwarding in a generic way rather than include code to parse each codec. \r\n\r\nTo be able to enable the SFU to do generic forwarding, the client can either configure a non-infinite MTU for RTP over QUIC streams or can send RTP over QUIC datagrams. Clients that only support RTP/UDP (e.g. browsers that only support WebRTC) could be handled by translating to RTP over QUIC streams if the alternative (RTP over QUIC datagrams) would result in fragmentation. ",
          "createdAt": "2022-10-16T00:37:32Z",
          "updatedAt": "2022-10-16T00:37:32Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I opened #43 to add a length field and allow multiple RTP packets per stream as you suggested, @murillo128.\r\n\r\nOne feature I removed by doing this is the ability of a receiver to request to cancel a stream by sending a `STOP_SENDING` frame, if the receiver knows that a packet is no longer needed. This doesn't work, if there are other packets following on the same stream and the receiver does not know if those are still required. We could add it back if we still require senders to open new streams for each ADU, but since they might be fragmented into multiple RTP packets, I am not sure if it is worth keeping this restriction only to enable receivers to cancel streams.\r\n\r\nWhat do you think about this?\r\n\r\n\r\n@aboba I agree that RTP over QUIC Datagrams and RTP over UDP may still lead to interop issues, but I don't know if there is anything we can do about it except to document it in the topology section?",
          "createdAt": "2022-10-17T10:40:34Z",
          "updatedAt": "2022-10-17T10:40:34Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I merged #43, which adds the length field and allows multiple packets per stream, and added an issue for the `STOP_SENDING` frame problem (#45). I also documented the second MTU interop issue in the new topology section. Closing this issue for now, but feel free to reopen or create new issues if I missed something.",
          "createdAt": "2022-10-24T15:35:27Z",
          "updatedAt": "2022-10-24T15:35:27Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I think that the important thing is to be clear about what topologies are tractable and which are more difficult.  Conferencing servers are quite different from generic translators; the former often have the codec-specific knowledge to re-packetize, whereas translators do not.  ",
          "createdAt": "2022-10-26T05:14:12Z",
          "updatedAt": "2022-10-26T05:14:12Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOFUmh7s5Usx1W",
      "title": "Receiver can't request stream cancellation vie STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/45",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim",
        "NotJustRTP"
      ],
      "body": "In #43 we added a length field to RTP packets that are sent over QUIC streams and allowed multiple packets per stream. Until now, it was possible for a receiver to request cancellation of a stream, if a packet is not needed anymore, e.g., because a deadline has passed. \r\n\r\nNow, since the receiver does not know how many packets to expect on a stream, it cannot know if it is safe to request cancellation, because the following packets may still be relevant.\r\n\r\nOne possible solution is to go back to one Application Data Unit (ADU) (e.g., one media frame) per stream, while still allowing this ADU to be fragmented into multiple RTP packets. ",
      "createdAt": "2022-10-24T15:32:06Z",
      "updatedAt": "2023-05-18T09:02:53Z",
      "closedAt": "2023-05-18T09:02:53Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "We need to be careful about ascribing meaning to STOP_SENDING since the interpretation could differ depending on what is being sent on the stream. If a new stream is sent for each frame, then STOP_SENDING would imply cancelling reception of one and only one frame. But if  SVC layers are sent on different streams, does a STOP_SENDING imply cancelling the sending of the layer sent on that stream?  Or if all frames are sent on a single stream, does STOP_SENDING mean that it is desired for the sender to pause sending that stream?\r\n\r\nUsing RTCP messages might be less ambiguous. ",
          "createdAt": "2023-02-23T23:13:46Z",
          "updatedAt": "2023-04-14T15:56:02Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "That is an interesting feature that I didn't think about before. Does it require some signaling to tell the receiver what layers are sent on which stream? How would a sender know when to restart sending the higher layer(s)?\r\n\r\nWhen we discussed this problem in London, there was a tendency to require the sender to close a stream after exactly one ADU. But it is unclear what an ADU is in different payload formats. For some audio codecs, that could lead to streams being closed after each frame containing only a few ms of data. That would then lead to a very large number of new streams. Too many streams could be a problem itself (see also #49), but it may also be unnecessary to transmit each of these audio frames independently.",
          "createdAt": "2023-02-24T09:22:02Z",
          "updatedAt": "2023-02-24T09:22:02Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "The receiver would need to know that the layers were segregated by stream. This could occur because the receiver requested a layer or because the sender set it up that way. If the receiver is getting one-way delay info, it could ask for more layers if the delay was stable and close to the transmission line, indicating low queuing and loss. But without probing, neither sender nor receiver can estimate the bottleneck bandwidth if the rate is well below that. So requesting more layers could result in increasing delays, indicating queue buildup.",
          "createdAt": "2023-02-24T15:06:51Z",
          "updatedAt": "2023-02-24T15:06:51Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This issue was discussed at IETF116, bringing up more details about the problem. We can drop the text around having `STOP_SENDING` as a feature that can be used to cancel a certain frame or even an SVC layer. However, we should add considerations about how a sender should react to an incoming `STOP_SENDING` frame. `STOP_SENDING` does not include an offset, so if the sender sent more than one media frame on that stream, it does not know which media frame the receiver intended to cancel. Receiving `STOP_SENDING` should not be treated as a request to retransmit any frames, there are RTCP messages for this already. I think the correct way to handle this would be to continue sending new media frames on new QUIC streams but without resending any media frame that was previously transmitted on the stream that received `STOP_SENDING`.\r\n\r\n@LPardue brought up the `CANCEL_PUSH` frame of HTTP/3, which solves a somewhat similar problem in HTTP/3. I am not sure how this could be mapped to RTP since we don't define any control messages so far, and I am not aware of any RTCP messages that could be used instead.\r\n\r\n@martinthomson recently submitted a new [draft for an `ENOUGH` frame](https://datatracker.ietf.org/doc/draft-thomson-quic-enough/) that adds an offset to `STOP_SENDING`. `ENOUGH` could inform the sender at which offset a receiver wants to cancel the stream. This would let the sender know which media frames to retransmit and which parts can be dropped. It would also indicate where to continue sending media on new QUIC streams.\r\n\r\nThe considerations about `STOP_SENDING` should also include an error code (see #76).",
          "createdAt": "2023-04-14T10:25:42Z",
          "updatedAt": "2023-04-14T10:25:42Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Clarifications to STOP_SENDING or RESET_STREAM can be helpful in guiding sender behavior.  But we also need to be clear what RTCP messages can be implied from QUIC semantics and which cannot.",
          "createdAt": "2023-04-14T16:13:43Z",
          "updatedAt": "2023-04-14T16:13:43Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOFUmh7s5ZNaHu",
      "title": "Provide detailed list of supported unicast topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/47",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Section 4.1 is an excellent start. I'd like to see a detailed list of supported RFC 7667 topologies in this draft, along with any additional considerations (the size mismatch between QUIC-RTP and UDP-RTP that's already described is a great example of what I'm thinking about).\r\n\r\nFeel free to assign this to me, of course. :wink:",
      "createdAt": "2022-12-14T13:59:05Z",
      "updatedAt": "2023-04-27T06:26:05Z",
      "closedAt": "2023-04-27T06:26:05Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed with @mengelbart and @joerg-ott, this might morph into enough informational guidance about how to use QUIC-RTP to justify splitting it into a separate document, which might or might not update RFC 7667, but that would be a call for @aboba and @JonathanLennox.",
          "createdAt": "2022-12-14T16:01:48Z",
          "updatedAt": "2022-12-14T16:01:48Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> As discussed with @mengelbart and @joerg-ott, this might morph into enough informational guidance about how to use QUIC-RTP to justify splitting it into a separate document, which might or might not update RFC 7667, but that would be a call for @aboba and @JonathanLennox.\r\n\r\nAnd, just like magic, the MUST required for using secure AVP profiles for non-RTP-over-QUIC paths interconnected to RTP-over-QUIC paths popped up. This is no longer informational guidance ... ",
          "createdAt": "2023-03-27T07:41:24Z",
          "updatedAt": "2023-03-27T07:41:24Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOFUmh7s5ZOZj5",
      "title": "Add any other relevant details about what QUIC feedback can replace AVP/AVPF feedback",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/48",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "SDP",
        "IETF116"
      ],
      "body": "This probably has impacts on SDP, depending on whether one QUIC/RTP endpoint needs to tell the other QUIC/RTP endpoint what feedback to send. ",
      "createdAt": "2022-12-14T16:06:13Z",
      "updatedAt": "2023-04-27T07:19:50Z",
      "closedAt": "2023-04-27T07:05:41Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "RTCP messages to consider include messages defined in RFCs 4585, 5104, 8888 and draft-ietf-avtcore-rtcp-green-metadata.",
          "createdAt": "2023-04-14T18:01:53Z",
          "updatedAt": "2023-04-14T18:01:53Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think 4585, 5104, and 8888 should all be included now, and I created a new issue to track draft-ietf-avtcore-rtcp-green-metadata: #79 ",
          "createdAt": "2023-04-27T07:19:50Z",
          "updatedAt": "2023-04-27T07:19:50Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOFUmh7s5ZOgZC",
      "title": "MAX_STREAMS and frame/stream transport",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/49",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF116",
        "NotJustRTP"
      ],
      "body": "A recent post on the MoQ list relates to the interaction of MAX_STREAMS and frame/stream transport:\r\nhttps://mailarchive.ietf.org/arch/msg/moq/hecXJfwaysqbyp85ZUwAT9I5CM0/\r\n\r\nLooking at the thread and after having done some experiments, there do appear to be scenarios (e.g. conferencing) where a low MAX_STREAMS limit could be exceeded. \r\n\r\nRelated: WebTransport API [Issue 446](https://github.com/w3c/webtransport/issues/446)",
      "createdAt": "2022-12-14T16:21:26Z",
      "updatedAt": "2023-05-18T09:03:04Z",
      "closedAt": "2023-05-18T09:03:04Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "We have been discussing this issue in the W3C WEBTRANSPORT WG.  Even though the MAX_STREAMS limit is cumulative, web browsers continually update the limit, based on the default maximum number of simultaneous streams on a QUIC connection (100 for Chrome).  The maximum number of simultaneous streams in use is determined by the maximum number of RTP streams and the level of concurrency (e.g. how many QUIC streams are simultaneously in use for each RTP stream).  \r\n\r\nThere are some scenarios in a limit of 100 simultaneous QUIC streams can be exceeded.  For example, consider a conference in which there are 50 participants and each RTP stream may have 4 QUIC streams in use at a time (e.g. 4 frames in transit).  This might require a limit of 200+ QUIC streams rather than 100.  ",
          "createdAt": "2023-02-23T23:21:02Z",
          "updatedAt": "2023-02-23T23:21:02Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The current draft says:\r\n\r\n> Opening new streams for new packets MAY implicitly limit the number of packets concurrently in transit because the QUIC receiver provides an upper bound of parallel streams, which it can update using QUIC MAX_STREAMS frames. The number of packets that have to be transmitted concurrently depends on several factors, such as the number of RTP streams within a QUIC connection, the bitrate of the media streams, and the maximum acceptable transmission delay of a given packet. Receivers are responsible for providing senders with enough credit to open new streams for new packets at any time.\r\n\r\nAs Christian mentioned on the MoQ list, a sender may need additional credits for background streams that are not RTP/RTCP. However, depending on the type of these background streams, they may or may not take some of the credit that is also used for media streams. According to [RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#name-controlling-concurrency), `max_streams` of 100 means that a sender can open `100 * 4 + first_stream_id_of_type` streams. `first_stream_id_of_type` can either be `2` if the sender is a client or `3` if it is a server (since we are only using unidirectional streams. If the background data transfer also uses unidirectional streams, it may be necessary to rate limit it to avoid the problem that it takes up all the credit all the time.\r\n\r\nThe level of concurrency depends on how the sender decides to use streams. The draft currently allows sending any number of packets on a stream or opening new streams at any time, but this may change (see #45). If the receiver knows the properties of the incoming media streams, how many there are, and how the sender uses QUIC streams, it may be able to calculate how often and by how much it must increase the MAX_STREAMS limit.",
          "createdAt": "2023-03-20T09:53:31Z",
          "updatedAt": "2023-03-20T09:53:31Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "I_kwDOFUmh7s5ZOpbl",
      "title": "QUIC interaction with ICE",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/50",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart",
        "joerg-ott"
      ],
      "labels": [
        "SDP",
        "IETF117"
      ],
      "body": "We need QUIC-ICE in order to support peer-to-peer operation, but some functionalities overlap between ICE and QUIC. For example,\r\n- QUIC validates addresses, and ICE nominates candidate pairs\r\n- QUIC Ping frames and ICE Keepalives\r\nAnd, of course, ICE prioritizes candidate pairs, which QUIC might have opinions about for connection migration. \r\n\r\nThat's probably an incomplete list. But we need to figure this out. ",
      "createdAt": "2022-12-14T16:43:15Z",
      "updatedAt": "2023-06-16T16:40:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "QUIC over ICE shipped in a [Chromium Origin Trial in 2019](https://developer.chrome.com/blog/rtcquictransport-api/), and these issues were addressed as follows: \r\n\r\n* QUIC connection migration was not enabled, since this was handled by ICE, just as SCTP migration is not supported in WebRTC data channel. \r\n\r\n* ICE keepalives were implemented, since the socket can be shared (e.g. QUIC, SRTP/SRTCP, DTLS, ZRTP can be multiplexed) and so you can't assume that the keepalives are solely handled by QUIC. \r\n\r\n* For similar reasons, you need both ICE connectivity checks and QUIC address validation. ",
          "createdAt": "2022-12-14T21:34:40Z",
          "updatedAt": "2022-12-14T21:34:40Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins and @mengelbart suspect that the ICE negotiations may belong in another document that this document will reference, saying \"you need an open validate QUIC connection, and if you can't find the other endpoint without ICE, you need to go look at ICE-for-QUIC and come back here when you do have an open valid QUIC connection\". ",
          "createdAt": "2023-06-16T16:40:42Z",
          "updatedAt": "2023-06-16T16:40:42Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOFUmh7s5ZO8vp",
      "title": "Possible use of QUIC multipath?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/51",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "NextDoc"
      ],
      "body": "We can easily imagine usages of QUIC-RTP that would benefit from multipath capabilities. There are likely a number of considerations that we need to think through - for instance, would we provide one path to the application, that uses multiple paths below the application, or would we expect the application to manage multiple paths on its own? \r\n\r\nSome details: \r\n\r\n- [Multipath Extension for QUIC](https://datatracker.ietf.org/doc/draft-ietf-quic-multipath/) is a QUIC working group draft now. \r\n- If we expect QUIC-RTP to use QUIC connection migration, we are already a long way toward a finished specification on how to use MPQUIC. \r\n- [Multipath RTP (MPRTP)](https://datatracker.ietf.org/doc/draft-ietf-avtcore-mprtp/) was adopted as an AVTCORE draft, but expired in 2016, due to lack of cycles for the folks who were working on it. \r\n- If we could resurrect MPRTP, we could provide a capability that RTCP understands. \r\n\r\nThis would need exploration, in order to propose a path forward. ",
      "createdAt": "2022-12-14T17:28:54Z",
      "updatedAt": "2023-02-13T15:45:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "If we are talking about RTP over QUIC over ICE (e.g. RTP over P2P QUIC) then we may not need QUIC connection migration, just as WebRTC data channel relied on ICE rather than SCTP connection migration.\r\n\r\nFor RTP over WebTransport, QUIC connection migration might be more interesting, since ICE is not involved.\r\n\r\nThen there is QUIC multipath versus multipath RTP. \r\n\r\n",
          "createdAt": "2022-12-14T21:28:44Z",
          "updatedAt": "2022-12-14T21:28:44Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOFUmh7s5ZPAI7",
      "title": "Possible use of QUIC Multicast? ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/52",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "NextDoc"
      ],
      "body": "QUIC does not have a [Multicast Extension for QUIC](https://datatracker.ietf.org/doc/draft-jholland-quic-multicast/) on its plate - this is currently an individual draft. \r\n\r\nIf $SOMEONE could move this draft forward in QUIC, and $SOMEONE could take on working through the details in AVTCORE, we could provide a QUIC-RTP that could support many of the [RFC 7667](https://datatracker.ietf.org/doc/rfc7667/) topologies that are currently out of scope for us. \r\n\r\nNo need for immediate attention to this issue, but it is something to keep in mind, until we decide that it's not. ",
      "createdAt": "2022-12-14T17:39:30Z",
      "updatedAt": "2023-02-13T15:45:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "There are no plans to support multicast in WebTransport, so I think we can rule that out. \r\n\r\nAre there any implementations of multicast over raw QUIC?  ",
          "createdAt": "2022-12-14T21:23:07Z",
          "updatedAt": "2022-12-14T21:23:07Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOFUmh7s5ZQNEi",
      "title": "Review of RTP over QUIC draft (Vidhi Goel)",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/53",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Posted to the AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/BA7LGvYhodx-PnnaKKPj2gcnzBc/\r\n\r\nHello Authors,\r\n\r\nI have read and reviewed draft-ietf-avtcore-rtp-over-quic-01 and below are my comments.\r\n\r\nGeneral comment - I think this draft will be really helpful for developers of real time applications in migrating to QUIC (from UDP and DTLS). The current draft touches on some important aspects such as multiplexing, de-depulication of RTCP feedback fields etc. But it needs some more details and clarifications regarding sections like congestion control, connection migration, multi path capability.\r\n\r\nSpecific comments - I am providing my comments section wise and there are a mix of minor nits, typos and major comments.\r\n\r\nSection 1. - A very big advantage of migrating to QUIC would be connection migration and MPQUIC. I think this should be mentioned in the intro and later described the impact of each of these on RTP. \r\nSection 3. - Current text - Such new media transport protocols may be covered elsewhere, e.g., in the MOQ WG. I don\u2019t think reference to MOQ is needed here. \r\nSection 6. - Multiplexing RTP/RTCP and non RTP (eg. HTTP) - since this will be discussed on Dec 15th interim, I will leave out my comment until a decision has been made.\r\nSection 6.1 - Current text - If it is known to either the sender, that a packet, which was not yet successfully and completely transmitted, is no longer needed.... Typo in the first part where \u201ceither\u201d is not needed.\r\nSection 7. - Typo in the word \u201cadditional\u201d -  QUIC layer to the application instead of exchanging addtional\r\nSection 7.1 - The list of replaceable RTCP reports appears without any pretext before \u201cReceiver Reports\u201d. A simple line that says what is coming next would solve it.\r\n                   - Under Receiver reports->Fractions lost, current text - Later packets SHOULD be ignored, since they may still be in flight, unless other QUIC packets that were sent after the datagram frame,. Why only sent after the datagram frame (and not stream) - maybe reframe the sentence to say RTP packet instead?\r\n\t\t   - Under Receiver reports->Highest Sequence Number received - This field is not clear. It would be clearer if it\u2019d say what does this field mean in RTP and can QUIC provide the exact same feedback from its ACKs.\r\n\t\t   - Negative acknowledgements - Probably make the recommendation clearer that since QUIC can provide all the information that a negative ack provides, there is no need to use RTCP negative Ack.\r\n   \t\t   - ECN feedback - same comment as above, clearly state that reporting of ECN feedback should be done via QUIC instead of RTCP feedback.\r\nSection 7.2 - English nit in current text - A QUIC receiver can also not calculate. Suggestion, Nor can a QUIC receiver calculate..\r\nSection 8 - This section needs some work IMO with regards to,\r\n\t1. What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n\t2. Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n\t3. If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nSection 10.2 - This is a sub section for impact of connection migration and it would be good to add one for MP QUIC as Multipath offers more benefits than migration. And, both the sections should clearly state if the RTP layer needs to do anything on path change.\r\n\t\t     - This line caught my attention - Application layer congestion control mechanisms (and also packet repair schemes such as retransmissions) need to be prepared to cope with such spikes.  Isn\u2019t this something they already deal with UDP anyway? I wasn\u2019t sure the reason for mentioning this explicitly.\r\n\r\nCommon to the entire draft - I think the word \u201cunreliable\u201d before datagrams doesn\u2019t really add to the value of the draft as we all know datagrams are not retransmitted and the word \u201cunreliable\u201d doesn\u2019t bring anything good to the table. Perhaps that can be removed at some places. The word congestion control is well known in the community but I think most real time drafts use the word \u201crate adaptation algorithm\u201d and that word makes more sense to me than congestion control. Happy to hear what the authors (and others) think.\r\n\r\nI can send out a PR for some of these comments.\r\n\r\nThanks,\r\nVidhi\r\n",
      "createdAt": "2022-12-14T21:20:49Z",
      "updatedAt": "2023-01-23T15:51:33Z",
      "closedAt": "2023-01-23T15:51:33Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @goelvidhi, as you can see, @aboba entered your review comments after the December virtual interim meeting. They are all in this issue, and most of the resolutions should be easy, so I will just respond to them as individual comments here, and they're likely to all end up in one PR. \r\n\r\nAnd thank you for your help!",
          "createdAt": "2023-01-12T20:19:35Z",
          "updatedAt": "2023-01-12T20:19:35Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 1. - A very big advantage of migrating to QUIC would be connection migration and MPQUIC. I think this should be mentioned in the intro and later described the impact of each of these on RTP.\r\n\r\nI have a couple of thoughts. \r\n\r\n- I agree that these advantages are worth mentioning, but one of the major points the authors are working on, is to specify as much as we **need** to specify, without waiting until we specify everything that **can** be specified. I'll mention both of these, without promising that they will be added in the short term.\r\n- QUIC connection migration is included in [RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-connection-migration), but Multipath QUIC is still an [Internet Draft](https://datatracker.ietf.org/doc/html/draft-ietf-quic-multipath-03). It's been adopted by the QUIC working group, but hasn't been WGLCed yet, so perhaps we should wait a bit before including details about how RTP can exploit multipath QUIC capabilities. \r\n\r\nI opened issue #51, and will follow up on this comment when I'm working on that issue. ",
          "createdAt": "2023-01-13T00:33:05Z",
          "updatedAt": "2023-01-16T23:00:27Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment:\r\n\r\n> Section 3. - Current text - Such new media transport protocols may be covered elsewhere, e.g., in the MOQ WG. I don\u2019t think reference to MOQ is needed here.\r\n\r\nSpencer agrees. Making this change now. ",
          "createdAt": "2023-01-13T00:34:02Z",
          "updatedAt": "2023-01-16T16:45:09Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 6. - Multiplexing RTP/RTCP and non RTP (eg. HTTP) - since this will be discussed on Dec 15th interim, I will leave out my comment until a decision has been made.\r\n\r\n@mengelbart has been working on this independently, in #54. Let's track this comment there. ",
          "createdAt": "2023-01-13T00:37:33Z",
          "updatedAt": "2023-01-16T16:48:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 6.1 - Current text - If it is known to either the sender, that a packet, which was not yet successfully and completely transmitted, is no longer needed.... Typo in the first part where \u201ceither\u201d is not needed.\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:38:25Z",
          "updatedAt": "2023-01-16T16:49:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 7. - Typo in the word \u201cadditional\u201d - QUIC layer to the application instead of exchanging addtional\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:39:15Z",
          "updatedAt": "2023-01-16T19:42:52Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 7.1 - The list of replaceable RTCP reports appears without any pretext before \u201cReceiver Reports\u201d. A simple line that says what is coming next would solve it.\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:40:03Z",
          "updatedAt": "2023-01-16T19:43:13Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>- Under Receiver reports->Fractions lost, current text - Later packets SHOULD be ignored, since they may still be in flight, unless other QUIC packets that were sent after the datagram frame,. Why only sent after the datagram frame (and not stream) - maybe reframe the sentence to say RTP packet instead?\r\n\r\nUpon reflection, Spencer suspects that this bullet really is datagram-specific, because QUIC (helpfully? :raised_eyebrow:) retransmits RTP packets carried in QUIC stream. A couple of paragraphs earlier, the text talks about direct mapping understating RTP losses and misstating RTP jitter when QUIC streams are used, and this might be clearer if it's restated in this bullet. \r\n\r\n@mengelbart, could you look at this, and tell me if I'm completely wrong? \r\n\r\nIn the meantime, I'm proposing this text, to make (my understanding of the point) clearer. \r\n\r\n  * *Fraction lost*: When RTP packets are carried in QUIC datagrams, the fraction of lost packets can be directly inferred from\r\n    QUIC's acknowledgments. The calculation SHOULD include all packets up to the\r\n    acknowledged RTP packet with the highest RTP sequence number. Later packets\r\n    SHOULD be ignored, since they may still be in flight, unless other QUIC\r\n    packets that were sent after the RTP packet frame, were already acknowledged.",
          "createdAt": "2023-01-13T00:42:23Z",
          "updatedAt": "2023-01-16T21:15:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment:\r\n\r\n> - Under Receiver reports->Highest Sequence Number received - This field is not clear. It would be clearer if it\u2019d say what does this field mean in RTP and can QUIC provide the exact same feedback from its ACKs.\r\n\r\nI'm proposing this text,\r\n\r\n  * *Highest Sequence Number received*: The highest sequence number received is\r\n    the highest sequence number of all RTP packets carried in a QUIC packet that was acknowledged.",
          "createdAt": "2023-01-13T00:43:12Z",
          "updatedAt": "2023-01-16T21:22:18Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> - Negative acknowledgements - Probably make the recommendation clearer that since QUIC can provide all the information that a negative ack provides, there is no need to use RTCP negative Ack.\r\n\r\nI'm proposing this text.\r\n\r\n  * The generic negative acknowledgment packet contains information about\r\n    packets which the receiver considered lost. {{Section 6.2.1. of !RFC4585}}\r\n    recommends to use this feature only, if the underlying protocol cannot\r\n    provide similar feedback. QUIC does not provide negative acknowledgments,\r\n    but can detect lost packets through acknowledgments based on the Gap numbers contained in QUIC ACK frames.",
          "createdAt": "2023-01-13T00:44:12Z",
          "updatedAt": "2023-01-16T21:31:39Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> - ECN feedback - same comment as above, clearly state that reporting of ECN feedback should be done via QUIC instead of RTCP feedback.\r\n\r\nThe draft currently says this.\r\n\r\n> QUIC\r\n>     supports ECN reporting through acknowledgments. If the connection supports\r\n>     ECN, the reporting of ECN counts SHOULD be done using QUIC acknowledgments.\r\n\r\nIf this isn't clear enough for the reader, I'm proposing this. \r\n\r\n  * ECN feedback packets report the count of observed ECN-CE marks. {{!RFC6679}}\r\n    defines two RTCP reports, one packet type (with `PT=205` and `FMT=8`) and a\r\n    new report block for the extended reports which are listed below. QUIC\r\n    supports ECN reporting through acknowledgments. If the connection supports\r\n    ECN, the reporting of ECN counts SHOULD be done using QUIC acknowledgments,\r\n    rather than RTCP ECN feedback reports.",
          "createdAt": "2023-01-13T00:45:10Z",
          "updatedAt": "2023-01-16T21:49:40Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 7.2 - English nit in current text - A QUIC receiver can also not calculate. Suggestion, Nor can a QUIC receiver calculate..\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:46:38Z",
          "updatedAt": "2023-01-16T21:50:43Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 8 - This section needs some work IMO with regards to,\r\n> 1. What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n\r\nI'm not sure what spec we should comply to, but I definitely agree that we should say explicitly that RFC 9002 isn't the only possible spec that makes sense for realtime applications! I'll propose text here. ",
          "createdAt": "2023-01-13T00:49:55Z",
          "updatedAt": "2023-01-13T00:49:55Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 8 - This section needs some work IMO with regards to,\r\n\r\n> 2. Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n\r\nI'll propose text here. ",
          "createdAt": "2023-01-13T00:51:21Z",
          "updatedAt": "2023-01-13T00:51:41Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 8 - This section needs some work IMO with regards to,\r\n> \r\n> 3. If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nMy opinion, and I'm sure we need to talk about this, is that for realtime media applications intended to run over the Internet, the application needs to do SOMETHING for (as you mention in another commend) rate adaptation. I'd make two observations here. \r\n\r\nFirst, and foremost, we don't have an agreed mechanism for how to tell a QUIC implementation at each end of a QUIC connection that this connection will be used to carry realtime media. Without that, the QUIC implementation has no way of knowing that the connection is not carrying HTTP/3, and we're going to get RFC 9002 behavior (or worse for realtime media, for example, BBF behavior). We should say that. \r\n\r\nSecond, for realtime media applications intended to run outside of controlled environments (as described in [RFC 8085](https://datatracker.ietf.org/doc/html/rfc8085#autoid-22), at a minimum, we can point to discussion about RTP circuit breakers in [RFC 8083](https://datatracker.ietf.org/doc/html/rfc8083).\r\n\r\nI've opened issue #59 to start more specific work on bandwidth estimation, rate adaptation, and congestion control, and will follow up there. ",
          "createdAt": "2023-01-13T01:27:20Z",
          "updatedAt": "2023-01-16T22:56:04Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 10.2 - This is a sub section for impact of connection migration and it would be good to add one for MP QUIC as Multipath offers more benefits than migration. And, both the sections should clearly state if the RTP layer needs to do anything on path change.\r\n\r\nThis is related to the comment about QUIC connection migration and MP-QUIC made for Section 1, and whatever we say in Section 10.2 should be summarized in Section 1. ",
          "createdAt": "2023-01-13T01:34:29Z",
          "updatedAt": "2023-01-13T01:34:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> - This line caught my attention - Application layer congestion control mechanisms (and also packet repair schemes such as retransmissions) need to be prepared to cope with such spikes. Isn\u2019t this something they already deal with UDP anyway? I wasn\u2019t sure the reason for mentioning this explicitly.\r\n\r\nI think this is related to our discussion of rate adaptation for a previous comment. I'll come back to this comment in #59.",
          "createdAt": "2023-01-13T01:38:39Z",
          "updatedAt": "2023-01-16T22:57:24Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For these two comments: \r\n\r\n> Common to the entire draft - I think the word \u201cunreliable\u201d before datagrams doesn\u2019t really add to the value of the draft as we all know datagrams are not retransmitted and the word \u201cunreliable\u201d doesn\u2019t bring anything good to the table. Perhaps that can be removed at some places. \r\n>\r\n> The word congestion control is well known in the community but I think most real time drafts use the word \u201crate adaptation algorithm\u201d and that word makes more sense to me than congestion control. Happy to hear what the authors (and others) think.\r\n\r\n1. At a minimum, we can say \"QUIC datagrams, which are unreliable\" once, and remove all other occurrences. @mengelbart and @joerg-ott would know better, but some of this text, or at least some of the thinking behind it, may date back to the days when the QUIC working group was talking about whether they also needed to support reliable datagrams, but these days, I don't think we need to be as careful about saying this clearly. \r\n\r\n2. \"rate adaptation algorithm\u201d works for me, and for @mengelbart.",
          "createdAt": "2023-01-13T01:45:03Z",
          "updatedAt": "2023-01-16T22:53:04Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thank you, Spencer, for preparing a PR!\r\n\r\nI don't know if you intentionally skipped the comments about the fraction lost and the highest sequence number fields of receiver reports, so I just opened two PRs to address these: https://github.com/mengelbart/rtp-over-quic-draft/pull/56 https://github.com/mengelbart/rtp-over-quic-draft/pull/57 (Feel free to ignore them if you already made changes for these, too).",
          "createdAt": "2023-01-13T09:16:00Z",
          "updatedAt": "2023-01-13T09:16:00Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> > Common to the entire draft - I think the word \u201cunreliable\u201d before datagrams doesn\u2019t really add to the value of the draft as we all know datagrams are not retransmitted and the word \u201cunreliable\u201d doesn\u2019t bring anything good to the table. Perhaps that can be removed at some places.\r\n> > The word congestion control is well known in the community but I think most real time drafts use the word \u201crate adaptation algorithm\u201d and that word makes more sense to me than congestion control. Happy to hear what the authors (and others) think.\r\n> \r\n>     1. At a minimum, we can say \"QUIC datagrams, which are unreliable\" once, and remove all other occurrences. @mengelbart and @joerg-ott would know better, but some of this text, or at least some of the thinking behind it, may date back to the days when the QUIC working group was talking about whether they also needed to support reliable datagrams, but these days, I don't think we need to be as careful about saying this clearly.\r\n\r\nMentioning that QUIC datagrams are unreliable once should be enough. The RFC 9221 also has \"unreliable\" in its name, so the reference should make clear that these are unreliable datagrams.\r\n \r\n>     2. \"rate adaptation algorithm\u201d works for me. Does it work for the authors (and, of course, for the working group, but let's start with @mengelbart and @joerg-ott).\r\n\r\n\"rate adaptation algorithm\" works for me when we talk about real-time media. I'd prefer to keep \"congestion control\" when talking about QUIC's congestion control because it is also the term used in RFC 9002.",
          "createdAt": "2023-01-13T09:30:25Z",
          "updatedAt": "2023-01-13T09:30:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n> I don't know if you intentionally skipped the comments about the fraction lost and the highest sequence number fields of receiver reports, so I just opened two PRs to address these: #56 #57 (Feel free to ignore them if you already made changes for these, too).\r\n\r\nYou're probably learning that I do a lot of stuff UNintentionally. When I read your comment, I instantly remembered that comment, so whoops, my bad. :zany_face: \r\n\r\nThank you for cleaning up after me, and opening these PRs. I'll work on them as well. \r\n\r\n",
          "createdAt": "2023-01-13T14:30:14Z",
          "updatedAt": "2023-01-13T14:30:14Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n\r\n> Mentioning that QUIC datagrams are unreliable once should be enough. The RFC 9221 also has \"unreliable\" in its name, so the reference should make clear that these are unreliable datagrams.\r\n\r\nThis actually turned out to be two mentions (one in the introduction, which precedes the terminology section, and one in the terminology section. \r\n\r\n",
          "createdAt": "2023-01-16T23:04:51Z",
          "updatedAt": "2023-01-16T23:04:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n\r\n> \"rate adaptation algorithm\" works for me when we talk about real-time media. I'd prefer to keep \"congestion control\" when talking about QUIC's congestion control because it is also the term used in RFC 9002.\r\n\r\nI touched a lot of text with this one - see what you think!\r\n\r\n",
          "createdAt": "2023-01-16T23:06:15Z",
          "updatedAt": "2023-01-16T23:06:15Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOFUmh7s5bRjMq",
      "title": "Catch up on acknowledgements to date",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/55",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "@mengelbart, I added Vidhi Goel when I was working through her review comments (#53), and (I hope this is OK) alphabetized the names that were already included so we can avoid omissions and duplications as we get more (and more) reviews and comments, but it will be good for you and @joerg-ott to make sure we have everyone who has helped so far. ",
      "createdAt": "2023-01-12T20:32:27Z",
      "updatedAt": "2023-02-20T08:24:09Z",
      "closedAt": "2023-02-20T08:24:09Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Alphabetized sounds good. I have more additions, but I will wait for your PR so we don't create unnecessary merge conflicts.",
          "createdAt": "2023-01-13T09:33:57Z",
          "updatedAt": "2023-01-13T09:33:57Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOFUmh7s5bWHFS",
      "title": "Scoping description for Abstract and Introduction ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/58",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Starting with material in https://notes.ietf.org/k36X3Z4MR_qXbHtI5HTXFA?edit",
      "createdAt": "2023-01-13T15:50:21Z",
      "updatedAt": "2023-02-20T08:46:25Z",
      "closedAt": "2023-02-20T08:46:25Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@joerg-ott put together an excellent first draft for the scope statement, in [HedgeDoc](https://notes.ietf.org/k36X3Z4MR_qXbHtI5HTXFA?edit). I'll start with that, stir, and season. ",
          "createdAt": "2023-01-27T14:56:20Z",
          "updatedAt": "2023-01-27T14:56:20Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOFUmh7s5bhsfr",
      "title": "CC/RA: Explain how to avoid nested congestion controller loops for real time media",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/59",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "The current draft says (in \"Congestion Control at the Application Layer\"), \r\n\r\n> If the application implements full congestion control rather than just a\r\n> bandwidth estimation at the application layer using a congestion controller that\r\n> satisfies the requirements of {{Section 7 of !RFC9002}}, and the connection is\r\n> only used to send real-time media which is subject to the application layer\r\n> congestion control, **it is RECOMMENDED to disable any other congestion control\r\n> that is possibly running at the QUIC layer**. Disabling the additional congestion\r\n> controllers helps to avoid any interference between the different congestion\r\n> controllers.\r\n\r\nWe have talked about this for at least a couple of years, back when \"RTP over QUIC\" was still in the QUIC working group, but as I understand it, there's no way to do this now (in a standardized way), and a plain reading of the emphasized text makes me think what's being described would require a QUIC extension. \r\n\r\nI don't care how we actually do this, but we need to write down how to do it!",
      "createdAt": "2023-01-16T22:31:46Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "closedAt": "2023-05-16T20:24:56Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Just noting down the points from my email that needs addressing,\r\n\r\n```\r\nSection 8 - This section needs some work IMO with regards to,\r\n1. What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n2. Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n3. If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n```",
          "createdAt": "2023-01-18T00:49:17Z",
          "updatedAt": "2023-01-18T00:49:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "From discussion with @joerg-ott and @mengelbart -\r\n\r\n- this is mostly about how a sending application tells a QUIC implementation what general type of congestion controller the QUIC implementation should use (say, NADA vs NewReno, \"please DON'T use an h3-optimized congestion controller for media\")\r\n- are we expecting the QUIC implementation to figure this out automagically? \r\n- how badly are h3-optimized congestion controllers going to work for application-limited, interactive applications?\r\n- Mathis work shows that rate-limited RTP rarely encounters QUIC limits that bulk transfer traffic would encounter",
          "createdAt": "2023-01-27T16:19:56Z",
          "updatedAt": "2023-01-27T16:19:56Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is about the proposal to disable QUIC's congestion controller, since a rate-limiting congestion controller is already in use at the application level. ",
          "createdAt": "2023-01-27T16:29:40Z",
          "updatedAt": "2023-01-27T16:29:40Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I replied to @goelvidhi s comments in #62 .\r\n\r\nI agree that the quoted text above is a bit unclear and maybe mixes a few things together that should be separated.\r\n\r\nI think as long as a sender complies to the congestion control requirements of QUIC as stated in RFC 9002/RFC 8085, it does not matter how it is implemented We might want to state this explicitly in the introduction to section 8 (see also #62).\r\n\r\nThe emphasized text above is about disabling one congestion controller when another is active as long as the active congestion controller applies to all outgoing traffic. The idea was to separate between an *RTP layer* and a *QUIC layer* and have the *RTP layer* do congestion control for real-time media. But that only works as long as the *RTP layer* is the only one sending data over the *QUIC layer*. As soon as the QUIC connection is shared between the *RTP layer* and some other datastream, congestion control must be done for both. \r\n\r\n> * this is mostly about how a sending application tells a QUIC implementation what general type of congestion controller the QUIC implementation should use (say, NADA vs NewReno, \"please DON'T use an h3-optimized congestion controller for media\")\r\n> * are we expecting the QUIC implementation to figure this out automagically?\r\n\r\nI don't see how a QUIC extension could help us solve this, but maybe this is rather an API question than a congestion control question?",
          "createdAt": "2023-02-01T12:57:22Z",
          "updatedAt": "2023-02-01T12:57:22Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Maybe we can discuss this issue either here or at #62. The general idea is to talk about the 3 options very clearly,\r\n1. CC/rate adaptation at both QUIC and RTP\r\n2. CC at QUIC only with necessary bandwidth estimation (perhaps other things) feedback provided from QUIC to RTP\r\n3. real time rate adaptation only with some compliance to 8085 - this one is tricky. Is there any existing rate adaptation algorithm that does this? If not, then this option is least preferable.\r\n\r\nI am not sure about the performance of option 1 and 2, so if there is some testing done for these, I would like to see the results. And testing on physical machines is preferable over emulators.\r\n",
          "createdAt": "2023-02-03T19:49:32Z",
          "updatedAt": "2023-02-03T19:51:33Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think there are multiple dimensions in which we can list different options. The first one is the layer at which congestion control is applied, either at the QUIC implementation layer or the application layer on top of QUIC or both. The second is the kind of congestion control used at both layers, which could for example be optimized for low latency or bulk transfer. And then, we have to distinguish between connections that are used for RTP only and connections that are shared between RTP and other non-RTP streams. Trying to break this down I get to something like this:\r\n\r\n### 0. No App CC + No QUIC CC \r\n\r\n  * Forbidden\r\n\r\n### 1. App CC + No QUIC CC\r\n\r\n* a) If only RTP runs on top of the QUIC connection, this can be any real-time rate adaptation that works well with RTP as long as it satisfies RFC 8085 and ideally also RFC 8836.\r\n* b) If RTP and non-RTP data share a QUIC connection, then all application protocols on top of that connection MUST do their own congestion control. It must be ensured that the result is still compliant with QUIC or RFC 8085 and that each stream receives a fair share of the bandwidth, which might be quite hard to get right.\r\n\r\n### 2. No App CC + QUIC CC\r\n\r\n* a) If only RTP runs on top of QUIC, the connection should ideally use a low latency congestion control algorithm and expose an estimated bandwidth to the application for codec configuration. This option looks very similar to 1a) above, because it is only an implementation detail where CC is implemented.\r\n* b) If RTP and non-RTP data share a connection, the congestion controller should assign bandwidth shares such that no stream can starve another.\r\n\r\n### 3. App CC + QUIC CC\r\n\r\n* a) For only RTP, this could be a potential fallback if 1a) and 2a) are not possible, e.g. because QUIC CC cannot do low latency or cannot expose the estimated bandwidth and it cannot be disabled either.\r\n* b) For a shared connection, this could be a potential fallback if 2b) is not possible.\r\n\r\n1a) and 2a) are very similar when we have free choice over which algorithms are used. 2b) seems the best choice for sharing connections. 3a) and 3b) don't seem to have any advantages but might be useful if other options are not available.\r\n\r\nRegarding real-time rate adaptation that is compliant to RFC 8085: I don't know for sure if the algorithms developed in RMCAT are compliant with RFC 8085, but since they were developed for environments that typically use UDP, I would be surprised if they are not. In any case, even if we can't or don't want to reference those algorithms explicitly, I don't think it should stop us from recommending algorithms that are optimized for low latency in general.\r\n",
          "createdAt": "2023-02-06T15:54:58Z",
          "updatedAt": "2023-02-06T15:54:58Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The discussion that @mengelbart and @goelvidhi have been having for this issue clarifies things quite a bit, even if the discussion mentioned \"disabling QUIC CC\" from time to time. The parts that don't assume that need to be inserted into the document as guidance, which is what we said at the [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).",
          "createdAt": "2023-03-09T17:23:04Z",
          "updatedAt": "2023-03-09T17:23:04Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOFUmh7s5cdSXl",
      "title": "Distinguish clearly between \"congestion control\" and \"rate adaptation\"",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/61",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "@goelvidhi mentioned this in her document review (sent to the mailing list, entered into #53 by @aboba), and I worked on this in #60, but where I ended up, was \r\n\r\n- it's helpful to distinguish between congestion control in general, and rate adaptation for interactive low-latency media, **but**\r\n- a significant number of RTP-centric specifications (for example, [RFC 8888](https://datatracker.ietf.org/doc/html/rfc8888)) use the term \"congestion control\" to describe what we're calling rate adaptation in this specification. \r\n\r\nI note that [RFC 8298](https://datatracker.ietf.org/doc/html/rfc8298) distinguishes between \r\n\r\n- Network Congestion Control, \r\n- Sender Transmission Control, and \r\n- Media Rate Control. \r\n\r\nSomething like that, early in this document, may be helpful. ",
      "createdAt": "2023-01-20T17:03:04Z",
      "updatedAt": "2023-02-20T08:25:14Z",
      "closedAt": "2023-02-20T08:25:14Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart said (in another review) that he agreed with the suggestion to add definitions for these terms early in the document. Perhaps prematurely, I renamed the Congestion Control section to be Congestion Control and Rate Adaptation in an earlier PR. ",
          "createdAt": "2023-01-23T15:59:19Z",
          "updatedAt": "2023-01-23T15:59:19Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOFUmh7s5cdWMv",
      "title": "QUIC congestion control, real-time congestion control, and (potentially) both, for the same QUIC connection",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/62",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "@goelvidhi had several questions about this interaction in her document review (sent to the mailing list, entered into #53 by @aboba), and it's worth mentioning this in a separate issue. \r\n\r\n- What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n- Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n- If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nThis is related to, but not the same as, #59 (if you don't want your media treated like H3 payloads, how do you tell the other endpoint that it's real-time media?). ",
      "createdAt": "2023-01-20T17:14:30Z",
      "updatedAt": "2023-03-09T19:38:16Z",
      "closedAt": "2023-03-09T17:13:59Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> * What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n\r\nSince we are running RTP on top of QUIC and one of our goals is not to change or extend QUIC if possible, I would argue that RFC 9002 is at least one of the specs that a congestion controller should comply with. RFC 9002 says:\r\n\r\n> A sender can unilaterally choose a different algorithm to use, such as CUBIC [[RFC8312](https://www.rfc-editor.org/rfc/rfc9002.html#RFC8312)].\r\n>\r\n> If a sender uses a different controller than that specified in this document, the chosen controller MUST conform to the congestion control guidelines specified in [Section 3.1](https://www.rfc-editor.org/rfc/rfc8085#section-3.1) of [[RFC8085](https://www.rfc-editor.org/rfc/rfc9002.html#RFC8085)].\r\n\r\nwhich is reflected in the current draft in section 8. The section references RTP congestion control mechanisms but doesn't define any requirements. I would suggest adding [RFC 8836 (Congestion Control Requirements for Interactive Real-Time Media)](https://datatracker.ietf.org/doc/rfc8836/) here.\r\n \r\n> * Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n\r\nI don't think there is anything that a media codec needs from a congestion controller. Calculating a bandwidth estimation helps because it allows the codec to produce media at a rate close to the maximum rate at which data can be transmitted to the receiver in real time. There may be more detailed signals available to improve the experience at the receiver, e.g., by changing the resolution or generating a new key fream, but I don't think this is the responsibility of congestion control.\r\n\r\n\r\n> * If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nIf a congestion controller does not comply with 1., it would be violating the QUIC specification. I think it is important that a sender complies with RFC 9002/RFC 8085 and RFC 8836 for real-time data, and using both congestion controllers might be a solution, although it might not be the best thing to do.\r\n\r\nShould we add some text to state more clearly, that a sender is expected to comply to the mentioned specifications?",
          "createdAt": "2023-02-01T12:38:28Z",
          "updatedAt": "2023-02-01T12:38:28Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Adding the specs to comply isn't a problem, its just that if QUIC CC is disabled, we have to make sure that it is feasible for the real time rate adaptation algorithm to comply to 8085. Does any of the current algorithms (Scream, NADA) reference 8085?",
          "createdAt": "2023-02-03T19:43:50Z",
          "updatedAt": "2023-02-03T19:43:50Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @goelvidhi - My understanding of the comments for this issue is that they all revolve around what we do if QUIC CC is disabled, and the guidance we have from the [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore) is **\"don't do that\"**. I think we can close this one. ",
          "createdAt": "2023-03-09T17:13:59Z",
          "updatedAt": "2023-03-09T17:13:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I agree with \"don't do that\", if \"QUIC CC is disabled\" means no congestion control is being done.\r\n\r\nIt might be helpful to have some definitions of terms like \"QUIC CC\", \"RTP CC\", \"Real-time CC\", etc. I tried to do that in https://github.com/mengelbart/rtp-over-quic-draft/issues/59#issuecomment-1419312129, because I think a lot of confusion comes from the different interpretations of these terms. \"QUIC CC\" might be used as \"the congestion controller running in the QUIC implementation\" or as \"the reno-like algorithm defined in RFC 9002\". Similarly, \"Real-time CC\" could mean \"congestion controller implemented in an application sending RTP\" or it might be used to reference a specific algorithm like SCReAM, NADA, or BBR.",
          "createdAt": "2023-03-09T17:38:25Z",
          "updatedAt": "2023-03-09T17:38:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree with \"don't do that\", if \"QUIC CC is disabled\" means no congestion control is being done.\r\n> \r\n> It might be helpful to have some definitions of terms like \"QUIC CC\", \"RTP CC\", \"Real-time CC\", etc. I tried to do that in [#59 (comment)](https://github.com/mengelbart/rtp-over-quic-draft/issues/59#issuecomment-1419312129), because I think a lot of confusion comes from the different interpretations of these terms. \"QUIC CC\" might be used as \"the congestion controller running in the QUIC implementation\" or as \"the reno-like algorithm defined in RFC 9002\". Similarly, \"Real-time CC\" could mean \"congestion controller implemented in an application sending RTP\" or it might be used to reference a specific algorithm like SCReAM, NADA, or BBR.\r\n\r\n@mengelbart - this is a super helpful suggestion. I created #70 to capture it.",
          "createdAt": "2023-03-09T19:38:15Z",
          "updatedAt": "2023-03-09T19:38:15Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOFUmh7s5eVZIM",
      "title": "Describe how RTP and non-RTP traffic sharing multiple QUIC connections on a single 5-tuple would work",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/65",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "We're starting with the idea that these types of traffic might not be using the same model for congestion control, but there's likely much more.",
      "createdAt": "2023-02-13T16:25:04Z",
      "updatedAt": "2023-06-16T15:38:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "When bulk transfer is enabled along with media, often the desire is for the bulk transfer not to interfere with the media.  To prevent that, the bulk transfer uses delay-based congestion control, same as for the media.  The bulk transfer will go slower, but that's often what the user wants. ",
          "createdAt": "2023-02-23T23:24:30Z",
          "updatedAt": "2023-02-23T23:24:30Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba - now that we're focusing on \"providing guidance\" about congestion control and rate adaptation, I think that saying what you said in your comment is the right thing to say in the document. ",
          "createdAt": "2023-03-09T17:17:42Z",
          "updatedAt": "2023-03-09T17:17:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We may want a clear description of the many levels of multiplexing we can be doing (at the same time).  It's turtles all the way down. ",
          "createdAt": "2023-05-17T16:55:02Z",
          "updatedAt": "2023-05-17T16:55:31Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "This is a slight tangent to the topic at hand, but I have thought a few times about this myself, and I keep coming back to the idea that multiplexing multiple application protocols within a single QUIC connection is better solved in a distinct standard as it has applicability beyond facilitating bulk data transfer alongside streaming media.\r\n\r\nFor example, I can see a use case where you could have streaming media, live chat and file sharing all in a single connection. I really don't want to negotiate a connection with an `rq` ALPN on a simple device, only to have to add all the edge cases where a peer could start trying to bundle bulk transfer in the same connection. Instead, I'm thinking about a QUIC protocol extension which on a connection negotiated with ALPN _a_, then says I'd like to also send application protocol _b_. There's then some extension (or replacement for) the `STREAM` frame that stipulates which application protocol the contents of a given stream are destined for. I think connection-level flow control will still be tricky, but I'd imagine such an extension would contain provisions for flow control on each stream dependent on which application protocol it is assigned to (this definitely needs more thought).\r\n\r\nI am surprised an ID for something like this hasn't cropped up yet and I don't know if anyone would be interested in writing one beyond myself. There's always the \"you can do it in WebTransport\" argument but not everything is a conversation between a web browser and a web server.",
          "createdAt": "2023-06-08T13:51:09Z",
          "updatedAt": "2023-06-08T13:51:09Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Sorry, hit comment early... \r\n\r\nSo the current draft says \r\n\r\n> If a receiver cannot associate a flow identifier with any RTP/RTCP or non-RTP stream, it MAY drop the data stream.\r\n\r\nIf that is not ideal, we could define another ALPN that only allows media streams, but that would make things more complicated. When we discussed multiplexing, one of the requirements was to enable use cases where one would like to send non-RTP data on the same connection.\r\n\r\n> There's then some extension (or replacement for) the STREAM frame that stipulates which application protocol the contents of a given stream are destined for.\r\n\r\nThat sounds like what we do with the flow identifier, but without using a QUIC extension or a new frame.\r\n\r\nI don't know if an extension that allows to change the application protocol would be useful. If I understand you correctly, you would then need some other way of negotiating the new protocols on top.\r\n\r\nWe could use a STREAM frame extension (or some other form of indicating what a stream contains) that allows multiplexing different application protocols, but I would consider that a different issue from the ALPN negotiation. ",
          "createdAt": "2023-06-12T17:21:17Z",
          "updatedAt": "2023-06-12T17:21:17Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Not sure why the RTP over QUIC spec should have normative statements relating to non-RTP/RTCP data.  This would be like RFC 3550 attempting to define the behavior of WebRTC data channel.  Yes, WebRTC data channel can be multiplexed with RTP/RTCP, but unless something has done wrong, WebRTC data channel packets will never be forwarded to the RTP/RTCP stack. \r\n\r\nIt's the same here. RTP/RTCP is an application running over the P2P QUIC transport, which takes care of delivering RTP/RTCP data to the RTP stack.   If data is being sent, P2P QUIC multiplexing makes sure that it is not delivered to RTP/RTCP.   \r\n\r\nAlso, there is no need for multiple ALPNs.  Just as WebRTC only defines one ALPN, in P2P QUIC there is only one ALPN. \r\n\r\n",
          "createdAt": "2023-06-12T18:56:45Z",
          "updatedAt": "2023-06-12T18:56:45Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think I agree mostly with what you're saying, but I am a bit lost about the P2P QUIC part. \r\n\r\nWe decided to define multiplexing using the flow identifier and the `rtp-mux-quic` ALPN because, as far as I know, there was nothing like P2P QUIC defined that would do these things for us. If that changed or will change, should we consider dropping multiplexing with non-RTP/RTCP data and relying on the P2P QUIC multiplexing and ALPN instead?",
          "createdAt": "2023-06-12T20:18:35Z",
          "updatedAt": "2023-06-12T20:18:35Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOFUmh7s5gazP1",
      "title": "CC/RA: Phrase discussion about congestion control/rate adaptation in terms of guidance, not normative should/musts",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/67",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Based on discussion at [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).",
      "createdAt": "2023-03-09T17:02:11Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "closedAt": "2023-05-16T20:24:56Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOFUmh7s5gaz0U",
      "title": "CC/RA: Remove mentions about \"disabling QUIC congestion control\", etc. ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/68",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Based on discussion at [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).",
      "createdAt": "2023-03-09T17:03:42Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "closedAt": "2023-05-16T20:24:56Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Sorry, I saw this too late: Maybe https://github.com/mengelbart/rtp-over-quic-draft/issues/62#issuecomment-1462480865 should have been posted here. I think a definition of \"QUIC CC\" would be helpful, and removing \"disabling QUIC congestion control\" sounds good because it sounds confusing. But it should be allowed to use SCReAM/NADA/... without also having to run a loss-based algorithm like Reno.",
          "createdAt": "2023-03-09T17:44:38Z",
          "updatedAt": "2023-03-09T17:44:38Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOFUmh7s5ga8Tv",
      "title": "CC/RA: Explain why we aren't making BCP recommendations for rate adaptation algorithms in this document",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/69",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Based on discussion at [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).\r\n\r\nWe should be describing considerations for people choosing congestion control and rate adaptation algorithms, of course. ",
      "createdAt": "2023-03-09T17:26:37Z",
      "updatedAt": "2023-05-11T07:49:34Z",
      "closedAt": "2023-05-11T07:49:34Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Rate Control is often application and codec-specific.  For example, in WebRTC an application can indicate that it prefers to maintain resolution or framerate in the event of congestion. There are also rate control algorithms that adjust quantization in response to congestion, but this is not always a good idea (e.g. if you are sharing text where maintaining readability is important).  So the RTP specifications and even RTP payload specs don't say much about rate control. \r\n\r\nCurrently, the RMCAT congestion control algorithms are Experimental, so that's a good reason to avoid making a recommendation, ",
          "createdAt": "2023-04-14T15:44:21Z",
          "updatedAt": "2023-04-14T15:44:21Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOFUmh7s5gbvdq",
      "title": "CC/RA: More clearly define what we mean by \"QUIC CC\", real-time media rate adaptation, etc. in this document.",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/70",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF116"
      ],
      "body": "Suggested by @mengelbart in a #62 [comment](https://github.com/mengelbart/rtp-over-quic-draft/issues/62#issuecomment-1462480865). ",
      "createdAt": "2023-03-09T19:36:53Z",
      "updatedAt": "2023-04-14T12:25:00Z",
      "closedAt": "2023-04-14T12:25:00Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "*Congestion Control* and *Rate Adaptation* are already defined in the terminology section. I would suggest adding the following definitions:\r\n\r\n* **Loss-based congestion control algorithm**: A congestion control algorithm that uses packet loss as a signal for congestion. Loss-based congestion control algorithms allow senders to send data on a path until packets are dropped by intermediary network elements, which the algorithm treats as a signal of congestion.\r\n* **Delay-based or Low-latency congestion control algorithm**: A congestion control algorithm that aims at keeping queues, and thus the latency, at intermediary network elements as short as possible. Delay-based congestion control algorithms use, for example, an increasing one-way delay as a signal of congestion.\r\n* **QUIC congestion controller**: A software component of a QUIC implementation that implements a congestion control algorithm.\r\n* **RTP congestion controller**: A software component of an RTP implementation that implements a congestion control algorithm.",
          "createdAt": "2023-03-20T12:06:13Z",
          "updatedAt": "2023-03-20T12:06:13Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - thanks for this proposed text. I have two suggestions, which I'll put in my PR, but what you said was super helpful. \r\n\r\n> Loss-based congestion control algorithm: A congestion control algorithm that uses packet loss as a signal for congestion. Loss-based congestion control algorithms allow senders to send data on a path until packets are dropped by intermediary network elements, which the algorithm treats as a signal of congestion.\r\n\r\nI'm being pedantic, but I would also include networks that provide ECN, which is typically treated as data loss (although Scalable Congestion Controllers treat ECN(1) differently\r\n\r\nAnd, actually I'd also include networks that support ECN(1) under \"Delay-based or Low-latency congestion control algorithm\". So, I guess that's two and a half suggestions? \r\n\r\n> RTP congestion controller: A software component of an RTP implementation that implements a congestion control algorithm.\r\n\r\nI THINK that this can also happen in an application using an RTP implementation, can't it? ",
          "createdAt": "2023-03-25T11:19:19Z",
          "updatedAt": "2023-03-25T11:19:19Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Including ECN sounds good to me. Do you suggest including them under loss-based, delay-based, or both?\r\n\r\n> I THINK that this can also happen in an application using an RTP implementation, can't it?\r\n\r\nYes, I think this is possible, but maybe it just depends on where you draw the line between the RTP implementation and the application?",
          "createdAt": "2023-03-27T02:35:55Z",
          "updatedAt": "2023-03-27T02:35:55Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I THINK that this can also happen in an application using an RTP implementation, can't it?\r\n> \r\n> Yes, I think this is possible, but maybe it just depends on where you draw the line between the RTP implementation and the application?\r\n\r\n@mengelbart - on thinking more (and more clearly), I don't think we need to address this here. ",
          "createdAt": "2023-03-27T08:01:20Z",
          "updatedAt": "2023-03-27T08:01:20Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDOFUmh7s5h22qf",
      "title": "PLEASE choose an acronym for \"RTP over QUIC\"!!!",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/74",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart",
        "joerg-ott"
      ],
      "labels": [],
      "body": "If we had a reasonable acronym for \"RTP-over-QUIC\", our specification would be more than a little bit easier to read. \r\n\r\nI'm not suggesting one - I think @mengelbart and @joerg-ott should have the honor of painting that bikeshed - but I think we need one badly, and I expect marketing types outside the IETF, or even participants in other SDOs, to pick one if we don't. \r\n\r\n:upside_down_face:",
      "createdAt": "2023-03-27T09:46:26Z",
      "updatedAt": "2023-04-27T07:14:15Z",
      "closedAt": "2023-04-27T07:14:15Z",
      "comments": [
        {
          "author": "samhurst",
          "authorAssociation": "NONE",
          "body": "Might I suggest [QRT](https://datatracker.ietf.org/doc/html/draft-hurst-quic-rtp-tunnelling)? \ud83d\ude07\r\n\r\nAlternatively, maybe just \"rq\", in the same way that HTTP-over-QUIC was originally \"hq\"?",
          "createdAt": "2023-03-27T09:55:31Z",
          "updatedAt": "2023-03-27T09:55:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "The obvious one is one syllable - RoQ. Why not?",
          "createdAt": "2023-03-28T05:27:16Z",
          "updatedAt": "2023-03-28T05:27:16Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "RoQ - I like it!",
          "createdAt": "2023-04-14T15:45:15Z",
          "updatedAt": "2023-04-14T15:45:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think RoQ makes sense as it also aligns with MoQ and DoQ. I also just talked to @joerg-ott and we agreed on using RoQ.  I'll open a PR.",
          "createdAt": "2023-04-14T16:00:50Z",
          "updatedAt": "2023-04-14T16:00:50Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOFUmh7s5h8XdB",
      "title": "Improve consideration for multi-hop topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/75",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "IETF117"
      ],
      "body": "So the QUIC connection carrying RTP will for now be point to point. However, as RTP has notion of RTP middleboxes that are used to create multiparty topologies there need to be better consideration for when one can do optimizations like reducing the rate of RTCP because the RTCP receiver related statistics will be known by QUIC sender. So if one can reduce the rate or even skip some RTCP reports is all dependent if the RTP middlebox that interconnects has full autonomy and can act on all aspects on the transport feedback. However, if the original sender in a system would monitor all receivers and actually adapt its general rates in a simulcast for example and the middlebox just selects between the simulcast versions then one would have to maintain RTCP reports that does cross reporting over the whole RTP session. \r\n\r\nSo I think you need to clarify for example in Section 6.1 that the system needs to decided on its need and use signalling to both configure the reports the system needs as well as the frequency of the RTCP reporting.  ",
      "createdAt": "2023-03-28T05:14:28Z",
      "updatedAt": "2023-05-17T16:58:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "I would also note that if a RTP session member does not send any RTCP receiver reports it might be classify it as not longer part of the session. RFC 3550 does only require one to send RTP/RTCP packets the last 5 reporting interval. However, I have feeling that many implementation will us SR or RR as equivalent to sending RTCP as they have been the base line. ",
          "createdAt": "2023-03-28T05:21:50Z",
          "updatedAt": "2023-03-28T05:21:50Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOFUmh7s5h8bFA",
      "title": "Important: define error codes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/76",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF117"
      ],
      "body": "Related to #13 but also applicable to the rest of the specification.\r\n\r\nRTP over QUIC is an application layer mapping for RTP applications. \r\n\r\nWhen using STOP_SENDING or RESET_STREAM, the code has to be an application-layer error code, and you don't have one. Without that, people will just pick random numbers (or worse, send 0 for everything). \r\n\r\nDefining codes isn't too hard, we should put some thought into gradeful or abrupt conditions that can be communicated via error codes",
      "createdAt": "2023-03-28T05:30:40Z",
      "updatedAt": "2023-06-16T15:40:38Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 77,
      "id": "I_kwDOFUmh7s5iK0bf",
      "title": "Add motivations for RoQ adoption",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/77",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF117"
      ],
      "body": "Add motivations for RQ work and adoption\r\n\r\nTransport-level encryption with RQ.\r\n\r\nUsing QUIC as it evolves (connection migration, and especially multipath QUIC).\r\n\r\nThinking about policy aspects of connection migration between interfaces (cheap WiFi vs expensive cellular).\r\n\r\nPotential connection sharing with other protocols over QUIC.\r\n\r\nQUIC path MTU discovery, especially in multiparty environments (today conference server has no option except using the lowest path MTU for all conference participants). \r\n\r\nACK piggybacking in QUIC if there are any QUIC frames going the other direction versus ACKs decreasing the available MTU for media. \r\n\r\nBeing clear about how RQ congestion control and flow control work.\r\n\r\nPossible advantage if audio is piggybacking on video in RQ - packaging multiple frames into a packet. \r\n\r\nThink about how multiple media quality variants would work - is there an advantage here?\r\n\r\nMultiplexing real-time and non-real-time flows. \r\n\r\nInteraction between QUIC congestion control and media congestion control. ",
      "createdAt": "2023-03-30T06:35:41Z",
      "updatedAt": "2023-06-16T16:29:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated motivations issues \r\n\r\nm-Transport-level encryption with RQ.\r\n\r\nm-Using QUIC as it evolves (connection migration, and especially multipath QUIC).\r\n\r\nm-Potential connection sharing with other protocols over QUIC.\r\n\r\nm-QUIC path MTU discovery, especially in multiparty environments (today conference server has no option except using the lowest path MTU for all conference participants).\r\n\r\nm-ACK piggybacking in QUIC if there are any QUIC frames going the other direction versus ACKs decreasing the available MTU for media. #85 \r\n\r\nm-Possible advantage if audio is piggybacking on video in RQ - packaging multiple frames into a packet.\r\n\r\nm-Multiplexing real-time and non-real-time flows.",
          "createdAt": "2023-05-17T16:33:41Z",
          "updatedAt": "2023-05-17T16:33:41Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The initial list for this issue are from discussions with with @gchandok at IETF 116. ",
          "createdAt": "2023-06-16T15:55:45Z",
          "updatedAt": "2023-06-16T16:27:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins requested this one be assigned to him, because he is likely responsible for similar text in the [MOQ Requirements draft](https://github.com/moq-wg/moq-requirements). ",
          "createdAt": "2023-06-16T16:29:32Z",
          "updatedAt": "2023-06-16T16:29:32Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOFUmh7s5kglq1",
      "title": "Add RTCP messages from draft-ietf-avtcore-rtcp-green-metadata",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/79",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "draft-ietf-avtcore-rtcp-green-metadata is not yet included in the list of feedback types",
      "createdAt": "2023-04-27T07:19:06Z",
      "updatedAt": "2023-06-16T15:46:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @JonathanLennox, **this is a process question** - do the chairs think draft-ietf-avtcore-rtcp-green-metadata is ready for us to include it in the RTP over QUIC discussion about mapping QUIC to RTCP feedback? \r\n\r\ndraft-ietf-avtcore-rtcp-green-metadata has been adopted as a working group draft, but it's the first I-D we're including in the QUIC-to-RTCP discussion - everything else has been an approved RFC. So I thought I should ask for guidance. ",
          "createdAt": "2023-04-27T15:21:34Z",
          "updatedAt": "2023-04-27T15:21:34Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @JonathanLennox, we haven't heard a response about our process question, and we are assuming that adding the rtcp-green-metadata is the Right Thing To Do, and will add it to our draft. Please tell us if this is wrong. ",
          "createdAt": "2023-06-16T15:10:08Z",
          "updatedAt": "2023-06-16T15:10:08Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOFUmh7s5kgnOk",
      "title": "Reference RTCP subsections from tables",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/80",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF117"
      ],
      "body": "The tables in sections [6.5](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-6.5) - [6.8](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-6.8) contain a lot of information which is also explained in more detail in section [6.3](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-6.3). I think we can reference the relevant subsections from the tables instead.",
      "createdAt": "2023-04-27T07:23:55Z",
      "updatedAt": "2023-06-16T16:25:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I agree that putting all of the material relating to a specific feedback mechanism in one place, and referring to it rather than adding text elsewhere makes sense. Here's what I was thinking about while working on PR #71.\r\n\r\n- some material is duplicated (in text and in tables), \r\n- some material is split (between text in tables), \r\n\r\nThat's roughly this issue. But, in addition, \r\n\r\n- It makes sense to me that we would have a list of what can be mapped between approved QUIC (RFC 9000 + RFC 9221) and RTCP, and a separate list of what could be mapped if we had one of the timestamps drafts (to help people understand why we need one of those drafts). Does that make sense to you? \r\n- I made the (not necessarily correct) decision to list everything that we looked at, whether it can be mapped between QUIC and RTCP or not, so we have a lot of table entries that say \"no\", even if some entries in the same table say \"yes\", and that's begging for us to also document why we think the answer is \"no\" (again, should we be adding that?)\r\n\r\nIt might make sense to move this second group of possible changes into its own, but (especially if we decide that spending a lot of effort on \"no\" entries isn't worth doing), we might be making to changes to text/tables/rows that we'll end up deleting from the document. \r\n\r\nDo you have thoughts about that? Should we have a short Slackathon to discuss?",
          "createdAt": "2023-04-27T15:02:26Z",
          "updatedAt": "2023-04-27T15:02:26Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> It makes sense to me that we would have a list of what can be mapped between approved QUIC (RFC 9000 + RFC 9221) and RTCP, and a separate list of what could be mapped if we had one of the timestamps drafts (to help people understand why we need one of those drafts). Does that make sense to you?\r\n\r\nI agree that having a list of what could be mapped with or without a timestamp extension would be helpful. I am not sure if that should be a separate table or if it would be enough to have an extra column for that.\r\n\r\n> I made the (not necessarily correct) decision to list everything that we looked at, whether it can be mapped between QUIC and RTCP or not, so we have a lot of table entries that say \"no\", even if some entries in the same table say \"yes\", and that's begging for us to also document why we think the answer is \"no\" (again, should we be adding that?)\r\n\r\nThat sounds good, too. I assume that the explanation would be the same for many of the fields so maybe we can do something similar to what you did in the topologies section, so we can reference the explanation/notes/subsection from all rows in the table to which it applies?\r\n",
          "createdAt": "2023-05-02T08:24:10Z",
          "updatedAt": "2023-05-02T08:24:45Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We may want to move some of these sections into an appendix (\"we looked at these and don't think they're useful, so other people don't have to wonder if we looked at them\").",
          "createdAt": "2023-05-17T17:05:42Z",
          "updatedAt": "2023-05-17T17:05:42Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "I_kwDOFUmh7s5lJPAz",
      "title": "Should we describe congestion control BEFORE we describe mapping QUIC feedback onto RTCP?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/82",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "I note that there is some material in the current Section 6 (\"Replacing RTCP and RTP Header Extensions with QUIC Feedback\") that \"prestates\" (it would be restating, but it comes before) the current Section 7 (\"Congestion Control and Rate Adaptation\"), but Step One would be to swap the two sections, and then review for clarity and continuity. \r\n\r\nFor example, [I-D.draft-smith-quic-receive-ts] and [I-D.draft-huitema-quic-ts] are mentioned more than once in each section, and it would be better if we explained what's going on once, on first use, and then just used references. ",
      "createdAt": "2023-05-05T02:32:39Z",
      "updatedAt": "2023-05-18T18:33:30Z",
      "closedAt": "2023-05-18T18:33:30Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Start with the section swap, and then edit looking for redundancies. ",
          "createdAt": "2023-05-17T17:07:07Z",
          "updatedAt": "2023-05-17T17:07:07Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOFUmh7s5ltjik",
      "title": "Add more detail to section 7.3 on congestion control when sharing connections with non-RTP streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/84",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "question",
        "Review outside AVTCORE needed"
      ],
      "body": "[Section 5.1](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic#section-5.1) explains in detail how multiplexing RTP with other protocols would work and [section 7.3](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic#section-7.3) is supposed to explain how to do congestion control for that. But the only sentence about this is rather vague:\r\n\r\n> Applications multiplexing multiple streams in one connection SHOULD implement some form of stream prioritization or bandwidth allocation.\r\n\r\nThis also came up in discussion with Gurtej and is slightly related to the discussion we had here: https://github.com/mengelbart/rtp-over-quic-draft/pull/83#discussion_r1191585178",
      "createdAt": "2023-05-11T19:45:15Z",
      "updatedAt": "2023-06-16T16:15:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We need informed opinions about the maturity of NADA/SCReAM competing with congestion controllers like BBR - probably a good question for CCWG (former [CONGRESS](https://datatracker.ietf.org/doc/charter-ietf-congress/)) when they are chartered. One way or another, this issue relies on expertise that is outside the core competence of many AVTCORE participants, even if some participants have that core competence. ",
          "createdAt": "2023-05-17T17:16:10Z",
          "updatedAt": "2023-06-16T16:15:34Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOFUmh7s5ltkx1",
      "title": "Add MTU vs. extra packet considerations for Acknowledgements when using datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/85",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "QUIC acknowledgment frames can be sent in the same packet as stream or datagram frames, which adds overhead and reduces the maximum size of datagram frames. If a packetizer is configured to produce packets at a fixed maximum MTU, the sender may need to send many extra QUIC packets for acknowledgments. It may be helpful to reference the acknowledgment frequency draft, which could help to reduce the overhead somewhat.\r\n\r\nMaybe relevant: https://www.rfc-editor.org/rfc/rfc9000#section-13\r\n",
      "createdAt": "2023-05-11T19:49:29Z",
      "updatedAt": "2023-07-10T16:29:52Z",
      "closedAt": "2023-07-10T16:29:52Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The fundamental problem this issue is pointing to, is that the RTP sender (and receiver) does not have visibility to non-data frames that a QUIC sender may include in an outgoing QUIC packet. So, not just QUIC ACKs. We can provide a description of the trade-offs in the document now, but we probably can't make specific recommendations (\"do this, not that\") in the document, at least not yet. ",
          "createdAt": "2023-06-16T16:08:25Z",
          "updatedAt": "2023-06-16T16:08:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "If we find that we are able to make specific recommendations, these recommendations may be added under a follow-up issue. ",
          "createdAt": "2023-06-16T16:18:14Z",
          "updatedAt": "2023-06-16T16:18:14Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "I_kwDOFUmh7s5ltlUH",
      "title": "Batching RTP packets in single QUIC packet",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/86",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Not Yet"
      ],
      "body": "Over UDP, every RTP packet gets sent in a UDP datagram. In QUIC, one could batch multiple small RTP packets together in a QUIC packet. This will probably happen automatically for streams but may depend on some scheduling for datagrams. That scheduling should take real-time requirements into account, i.e., try to optimize by batching, but also not delay packets too much.\r\n\r\nMaybe relevant: https://www.rfc-editor.org/rfc/rfc9000#section-13\r\n",
      "createdAt": "2023-05-11T19:51:13Z",
      "updatedAt": "2023-06-16T16:02:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Batching RTP packets is something that QUIC implementations can do, and @mengelbart and @SpencerDawkins think this is worth noting in the document, but it seems more useful to wait until we have some experience that tells us whether this will matter (assuming a conforming QUIC implementation) before we add text about recommendations implementers of RTP senders should consider. . ",
          "createdAt": "2023-06-16T15:59:56Z",
          "updatedAt": "2023-06-16T15:59:56Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOFUmh7s5ltnbS",
      "title": "Are real-time congestion controllers tied to RTP or usable in QUIC stacks?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/87",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "Review outside AVTCORE needed"
      ],
      "body": "SCReAM, NADA, and GCC were specifically designed with RTP/RTCP in mind. Is it feasible to use one of these in the QUIC stack itself, or are there other alternatives that could be implemented directly in a QUIC stack to follow the recommendations given in [section 7.1](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-7.1)? One requirement that all of the RMCAT algorithms have is that they need timestamps, which could be provided by one of the QUIC timestamp extension drafts.\r\n\r\nThis came up in discussion with Gurtej and again in https://github.com/mengelbart/rtp-over-quic-draft/pull/83#discussion_r1190525045\r\n",
      "createdAt": "2023-05-11T19:57:00Z",
      "updatedAt": "2023-06-16T15:51:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "IMO, it would be ideal to implement a real time rate adaptation algorithm in the QUIC stack and then expose an API for bitrate estimation to the application/framework that uses that to call into encoder. I can take this issue but do we need a PoC before making this text change?",
          "createdAt": "2023-06-10T01:01:03Z",
          "updatedAt": "2023-06-10T01:01:03Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I agree with that. I think a PoC and some experiments exploring such an implementation would be nice. I had this on my list for some time now but didn't get to implement it yet. I don't know if we need it before changing any text, but it might give some insights that could be useful to document.",
          "createdAt": "2023-06-12T17:26:34Z",
          "updatedAt": "2023-06-12T17:26:34Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOFUmh7s5mDuup",
      "title": "List all QUIC extensions documents that might be useful for RoQ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/92",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF117"
      ],
      "body": "RoQ does not require any QUIC extensions, but there are a few extension documents referenced in the document, and it would be helpful to have a complete list of extensions that might be useful for RoQ. The list should include the timestamp draft(s) and the ENOUGH frame and maybe more.",
      "createdAt": "2023-05-16T15:26:17Z",
      "updatedAt": "2023-06-16T15:44:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 93,
      "id": "I_kwDOFUmh7s5mLgfc",
      "title": "Using streams, datagrams, and per-RTP-frame streams with RoQ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/93",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "We may need a short section explaining the ROQ-specific tradeoffs",
      "createdAt": "2023-05-17T16:52:12Z",
      "updatedAt": "2023-06-16T15:23:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 95,
      "id": "I_kwDOFUmh7s5mUaiC",
      "title": "Add header extensions to RTCP analysis",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/95",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "In #71 we added a section about header extensions to the RTCP analysis, but it does not include a table of all header extensions we considered. I think it makes sense to add one, just like we did for the RTCP packets, too.",
      "createdAt": "2023-05-19T05:17:31Z",
      "updatedAt": "2023-06-16T15:45:01Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 103,
      "id": "I_kwDOFUmh7s5q87Zq",
      "title": "Reference new CLOSE_STREAM draft",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/103",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-07T21:10:36Z",
      "updatedAt": "2023-07-07T21:10:36Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 104,
      "id": "I_kwDOFUmh7s5rGQIx",
      "title": "Add @spencerdawkins as co-author",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/104",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-10T13:35:33Z",
      "updatedAt": "2023-07-10T19:42:09Z",
      "closedAt": "2023-07-10T19:42:09Z",
      "comments": []
    },
    {
      "number": 107,
      "id": "I_kwDOFUmh7s5r5MRf",
      "title": "Clean up introduction of \"RTP over QUIC\" and \"RoQ\" terms in the draft",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/107",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "ISTM that \"RTP over QUIC\" and \"RoQ\" should appear in the Abstract and Introduction, but neither does, and we don't actually say that we're going to be referring to \"RTP over QUIC\" as \"RoQ\" in the document. ",
      "createdAt": "2023-07-18T15:21:14Z",
      "updatedAt": "2023-07-18T16:04:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "We have the following in the introduction:\r\n\r\n> The mapping described in this document is called RTP over QUIC (RoQ).\r\n\r\nBut adding it to the abstract might be good, too.",
          "createdAt": "2023-07-18T16:04:08Z",
          "updatedAt": "2023-07-18T16:04:08Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI4OTU5NzUz",
      "title": "Draft section about used RTP/RTCP packets and restrictions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/1",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-03T09:13:51Z",
      "updatedAt": "2021-05-17T10:29:16Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "15dfd07af0ac380d51b42c952e096d2ee41e3c7e",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "rtcp-restrictions",
      "headRefOid": "e691a73184a513899fe992c574057897fa342577",
      "closedAt": "2021-05-08T15:47:21Z",
      "mergedAt": "2021-05-08T15:47:21Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "c416b71a37b9ff8891c9ba62af876c9e9c25334c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ1NzY5NzY2",
      "title": "Add identifiers to the cc interface",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/2",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-17T11:08:02Z",
      "updatedAt": "2021-05-17T16:53:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "386a04a2a6985f77ba9e9e4b4d46f8ba3b890ac8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "add-interface-identifiers",
      "headRefOid": "cb6e602846ddc421cad78b5dae14d2f065b7e35a",
      "closedAt": "2021-05-17T16:31:42Z",
      "mergedAt": "2021-05-17T16:31:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3fdbd66070a57196e538e1c4eaa389d262d47ebe"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY2MDA0MzA4",
      "title": "Update draft-engelbart-rtp-over-quic.md",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/3",
      "state": "MERGED",
      "author": "joerg-ott",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi Mathis, some thoughts on SDP signalling and a concrete example are in now. The detailed protocol procedures would likely be quite lengthy, so for an initial draft to see what people think, this might be good enough.",
      "createdAt": "2021-06-09T15:06:48Z",
      "updatedAt": "2021-06-09T16:53:49Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "79e265cabab1ee3f33e7cf696ba733bd871ab467",
      "headRepository": "joerg-ott/rtp-over-quic-draft",
      "headRefName": "patch-1",
      "headRefOid": "93749c47fdcc372668de6d4e81cdb6f3626688c8",
      "closedAt": "2021-06-09T16:53:49Z",
      "mergedAt": "2021-06-09T16:53:49Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "cb8fdaa379c3f9dea77140481c7f1649fabe0049"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgwNjgxMjk1",
      "title": "Fix typos and clarify some terminology",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/4",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-30T09:18:32Z",
      "updatedAt": "2022-03-04T09:35:59Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f7bd274edc900fb100e7a6cd749a98f457831150",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "terminology",
      "headRefOid": "137b2a4313d2445adfffa77e6fdf60c92eca8b5e",
      "closedAt": "2021-07-11T16:59:30Z",
      "mergedAt": "2021-07-11T16:59:30Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3f76be963765d4267472d6fbbfa863c040303266"
      },
      "comments": [
        {
          "author": "joerg-ott",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Quick note: in a few places, we may need to speak of \"RTP and RTCP packets\" instead of just \"RTP packets\".\r\nAnd I noticed: \"A RTP packet\" -> \"An RTP packet\"",
          "createdAt": "2021-07-11T16:34:15Z",
          "updatedAt": "2021-07-11T16:34:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> Quick note: in a few places, we may need to speak of \"RTP and RTCP packets\" instead of just \"RTP packets\".\r\n> And I noticed: \"A RTP packet\" -> \"An RTP packet\"\r\n\r\nMakes sense. I'll merge this PR first and then create another one for these changes. ",
          "createdAt": "2021-07-11T16:59:24Z",
          "updatedAt": "2021-07-11T16:59:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzNjA1MDM4",
          "commit": {
            "abbreviatedOid": "137b2a4"
          },
          "author": "joerg-ott",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-11T16:33:06Z",
          "updatedAt": "2021-07-11T16:33:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzNjA1MzE1",
          "commit": {
            "abbreviatedOid": "137b2a4"
          },
          "author": "joerg-ott",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-11T16:37:01Z",
          "updatedAt": "2021-07-11T16:37:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3MzgwNzA3",
      "title": "Always name both, RTP and RTCP where applicable",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/5",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-11T18:57:12Z",
      "updatedAt": "2022-03-04T09:35:56Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3f76be963765d4267472d6fbbfa863c040303266",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "always-name-rtp-and-rtcp",
      "headRefOid": "fff6f1b82db8b5e6844fcc5bf79002e96f0ac908",
      "closedAt": "2021-07-12T10:22:18Z",
      "mergedAt": "2021-07-12T10:22:18Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "4f0fea14d24c04f29aa3fcafe0e4f79c5400c042"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzODQxNTgy",
          "commit": {
            "abbreviatedOid": "fff6f1b"
          },
          "author": "joerg-ott",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T08:20:58Z",
          "updatedAt": "2021-07-12T08:20:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3NjU4MzI0",
      "title": "Update outdated Draft/RFC references",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/6",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-12T09:15:38Z",
      "updatedAt": "2022-03-04T09:35:55Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3f76be963765d4267472d6fbbfa863c040303266",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "update-references",
      "headRefOid": "15f11672d191f67668d8f0fb76be4d4a5eaf4f71",
      "closedAt": "2021-07-12T10:25:39Z",
      "mergedAt": "2021-07-12T10:25:39Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "e3a010e93ca98f3728f88125b02dc24567d59720"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOFUmh7s40AhbR",
      "title": "Restructure to focus on possible CC schemes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/7",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-06T22:25:47Z",
      "updatedAt": "2022-05-20T08:08:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f6d8759952dd0467d94a90af3cdb242047ac2d48",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "restructure",
      "headRefOid": "f579bd940804a8ff627aba79e9080845ee43e5be",
      "closedAt": "2022-03-07T17:22:13Z",
      "mergedAt": "2022-03-07T17:22:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f579bd940804a8ff627aba79e9080845ee43e5be"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOFUmh7s43e6Ao",
      "title": "Update congestion control and RTCP sections",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/8",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-09T08:01:31Z",
      "updatedAt": "2022-05-20T08:08:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0fc59ccb6beec441751e338c93cf6f00b22ad8bc",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "03-updates",
      "headRefOid": "1f2fbc66d74f92fc40536a9be6b1ce93220c7715",
      "closedAt": "2022-05-12T06:46:45Z",
      "mergedAt": "2022-05-12T06:46:45Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2f9992fd4237f1ecfed20eeeee3332019344e989"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOFUmh7s43oL2r",
      "title": "Rtp over quic streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/9",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-11T07:45:02Z",
      "updatedAt": "2022-05-20T08:08:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2f9992fd4237f1ecfed20eeeee3332019344e989",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "rtp-over-quic-streams",
      "headRefOid": "a4a771f55a825fe6d7a51b7d8ba550b27f66c2c3",
      "closedAt": "2022-05-12T06:49:02Z",
      "mergedAt": "2022-05-12T06:49:02Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5566b2ff06e22076423b0a8299c02a793826f805"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOFUmh7s44LJBs",
      "title": "Remove SDP section and fix some small issues",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/10",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-20T08:42:44Z",
      "updatedAt": "2022-07-19T07:32:34Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "5566b2ff06e22076423b0a8299c02a793826f805",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "04-updates",
      "headRefOid": "146a67e11b0daf16dc076f382d3ffe359885cdfd",
      "closedAt": "2022-06-24T07:30:05Z",
      "mergedAt": "2022-06-24T07:30:05Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "22e9908ca3a81b5d070c5215e720392e408e5bee"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOFUmh7s46QnSp",
      "title": "Update draft-engelbart-rtp-over-quic.md",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/12",
      "state": "MERGED",
      "author": "joerg-ott",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Various extensions: Scope, ALPN, Connection sharing, Discussion, various bits.",
      "createdAt": "2022-06-23T17:13:27Z",
      "updatedAt": "2022-06-24T07:20:10Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "04-updates",
      "baseRefOid": "2822ebc362f1c780cf5ec6a628048f4297b4f52b",
      "headRepository": "joerg-ott/rtp-over-quic-draft",
      "headRefName": "patch-3",
      "headRefOid": "c2277e23e182749891134a20f39fb3adf8009653",
      "closedAt": "2022-06-24T07:20:10Z",
      "mergedAt": "2022-06-24T07:20:09Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "66b788f2a38b4b5665947ed48cf3bc1b0551570f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOFUmh7s46avDw",
      "title": "Clarify stream types and explain stream closing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/17",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This PR clarifies which stream types are used (#14) and adds an explicit requirement to close streams once a packet was completely sent. Maybe we can also add considerations about stream concurrency (#15) here?",
      "createdAt": "2022-06-27T13:43:48Z",
      "updatedAt": "2022-09-23T07:22:48Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "clarify-stream-usage",
      "headRefOid": "cda9b732f0efbc9cb80f3d5a0dd271cbd491055e",
      "closedAt": "2022-09-23T07:18:16Z",
      "mergedAt": "2022-09-23T07:18:16Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3dc40e5272c11761dadf086c4aa09ccac3e9fdda"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOFUmh7s47ZFKY",
      "title": "Update adopted name",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/18",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-14T09:23:11Z",
      "updatedAt": "2022-09-12T13:52:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "22e9908ca3a81b5d070c5215e720392e408e5bee",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "update-adopted-name",
      "headRefOid": "6274d14609a982be97c5f8749be2ef82929a577c",
      "closedAt": "2022-07-19T07:36:44Z",
      "mergedAt": "2022-07-19T07:36:44Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d556493e4c9539aa8613f81599e9f200e68a3d75"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOFUmh7s48NSGD",
      "title": "Clarify which flow id to use for retransmissions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/19",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #16 ",
      "createdAt": "2022-07-27T20:53:15Z",
      "updatedAt": "2022-09-23T07:22:50Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "clarify-retransmission-flow-id",
      "headRefOid": "33019b0e75bbaea289c40182e2b2ee5baad27e2a",
      "closedAt": "2022-09-12T13:54:22Z",
      "mergedAt": "2022-09-12T13:54:22Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8b1c3e1a4dd08c56d933e79fbbecf30eb4ffa088"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 28,
      "id": "PR_kwDOFUmh7s48jk1c",
      "title": "Remove TODO because it was done by adding sec. 8.3",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/28",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #20 ",
      "createdAt": "2022-08-03T07:49:30Z",
      "updatedAt": "2022-09-12T13:52:02Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "remove-shared-connection-todo",
      "headRefOid": "bda42b73707548953173646721be3925a7e9c5b1",
      "closedAt": "2022-09-12T13:45:26Z",
      "mergedAt": "2022-09-12T13:45:26Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "53acd6ef5e4f0247c4ee50eab0de921d4c8388c7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 30,
      "id": "PR_kwDOFUmh7s48okeT",
      "title": "Remove note about possible use of RTCP in QUIC CC",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/30",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #23 ",
      "createdAt": "2022-08-04T09:21:08Z",
      "updatedAt": "2022-09-12T13:51:48Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "delete-rtcp-quic-cc-note",
      "headRefOid": "77aff38d80ee441c98455424d1e5e3fd5c0f3828",
      "closedAt": "2022-09-12T13:46:33Z",
      "mergedAt": "2022-09-12T13:46:33Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2c8f9243df75eecdd180e79544cf294990fbd396"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Also fixes #11 ",
          "createdAt": "2022-08-04T09:22:43Z",
          "updatedAt": "2022-08-04T09:22:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 32,
      "id": "PR_kwDOFUmh7s48qrHe",
      "title": "Delete note because it won't be a problem",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/32",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "closes #22 ",
      "createdAt": "2022-08-04T17:10:24Z",
      "updatedAt": "2022-09-12T13:51:46Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2c8f9243df75eecdd180e79544cf294990fbd396",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "delete-delay-based-cc-note",
      "headRefOid": "04ba7637bfd1e38f8ea439b2831fd79d1ec45352",
      "closedAt": "2022-09-12T13:51:06Z",
      "mergedAt": "2022-09-12T13:51:06Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "710f7cf91c079d10da8819655f47711687aade15"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "PR_kwDOFUmh7s4-w8lx",
      "title": "Clarify what *adequate congestion control* means",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/33",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Reference RFC 9002 and 8085 to clarify what adequate congestion control means. closes #26 ",
      "createdAt": "2022-09-12T09:17:13Z",
      "updatedAt": "2022-09-23T07:22:40Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "cite-cc-requirements",
      "headRefOid": "a6eaa3ffe0b7e3890a0b3270c1748f8cb3637f64",
      "closedAt": "2022-09-23T07:19:09Z",
      "mergedAt": "2022-09-23T07:19:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOFUmh7s4-yJAB",
      "title": "Stream concurrency considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/34",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-12T13:17:02Z",
      "updatedAt": "2022-10-24T14:28:41Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "stream-concurrency-considerations",
      "headRefOid": "1bfbfdfb99bd9db7734530440fc7a6eef12b7fdc",
      "closedAt": "2022-10-24T14:28:41Z",
      "mergedAt": "2022-10-24T14:28:40Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "413d581274edc938e14112cbb917c7557091cf48"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "PR_kwDOFUmh7s4-y4Ln",
      "title": "State requirements instead of certain algorithms",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/36",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-12T15:37:16Z",
      "updatedAt": "2022-10-24T14:41:47Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "cc-requirements",
      "headRefOid": "95797c0a352853695d88558a36135ed0f863c8fa",
      "closedAt": "2022-10-24T14:41:46Z",
      "mergedAt": "2022-10-24T14:41:46Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "651d67471b525e2343e7a2d9e9fa08fc35070e97"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 37,
      "id": "PR_kwDOFUmh7s4_Ls2d",
      "title": "Add recommendation to expose estimated bandwidth",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/37",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #35 ",
      "createdAt": "2022-09-19T09:10:17Z",
      "updatedAt": "2022-09-23T07:22:31Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "8b1c3e1a4dd08c56d933e79fbbecf30eb4ffa088",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "add-bandwidth-estiation-api",
      "headRefOid": "f10ba95ccd7b7eda4b32ac155f1e853d7451e688",
      "closedAt": "2022-09-22T08:50:13Z",
      "mergedAt": "2022-09-22T08:50:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f1afdd8ff421a4d143a238427d0c5730c3b4cb21"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "PR_kwDOFUmh7s4_LtF9",
      "title": "Relax CC API configuration requirement",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/38",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "resolve #27 ",
      "createdAt": "2022-09-19T09:11:12Z",
      "updatedAt": "2022-10-24T15:00:36Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "api-for-congestion-controller-configuration",
      "headRefOid": "7527d2080b19e5d4587019e33df1bf0e20b197f4",
      "closedAt": "2022-10-24T15:00:34Z",
      "mergedAt": "2022-10-24T15:00:34Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8e4b8d8cca656b8faa2881aa8de87d0c507bc9ea"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 40,
      "id": "PR_kwDOFUmh7s4_eh7c",
      "title": "Add topology subsection",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/40",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-23T07:11:45Z",
      "updatedAt": "2022-10-24T15:26:29Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d562b3b4786f7cf566efab3afa98bc27156dd2a7",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "rtp-topology-considerations",
      "headRefOid": "ff1e84968415e0dac3c289d5e028ff8e126ac385",
      "closedAt": "2022-10-24T15:26:28Z",
      "mergedAt": "2022-10-24T15:26:28Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "a1326e571e772fb6bad0924ab54fe4f7151500df"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks!\r\n\r\nI added another commit with the changes you suggested. I added a sentence about forwarding RESET_STREAM frames to section 6.1 because I think it might be confusing to reference the concept of closing streams via RESET_STREAM frames early in the document (even before the mapping to streams is introduced).\r\nAlternatively, we could move the topology considerations section to the back of the document.",
          "createdAt": "2022-09-29T10:20:59Z",
          "updatedAt": "2022-09-29T10:20:59Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "\"Once the RTP packet has been completely transmitted, the sender MUST gracefully close the stream.\"\r\n\r\n[BA] How does the translator know that the RTP packet has been completely transmitted?  It could know if it receives a FIN, or alternatively if there is a length field at the beginning of the packet. But what happens if it never receives the full length (or a RESET_STREAM)?\r\n\r\nIf the translator implements \"cut through\" behavior, rather than \"store and forward\", sending what it receives (including a FIN or a RESET_STREAM) it would seem that the above text isn't necessary.  The translator could function, even in situations where it wouldn't know if the RTP packet has been completely transmitted. ",
          "createdAt": "2022-09-29T14:10:00Z",
          "updatedAt": "2022-09-29T14:13:37Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I am not sure I understand your question. I added the sentence in https://github.com/mengelbart/rtp-over-quic-draft/pull/17 to make sure a sender closes the stream after each packet so that a receiver knows when the packet was completely received. We may delete it again if we decide to add a length field, but I'd like to keep it for now. If a translator never receives the full length there will be a RESET_STREAM, which it then has to forward:\r\n\r\n> A translators that translates between two endpoints, which are both connected via QUIC, MUST forward RESET\\_STREAM frames received from one end to the other end, unless it is forwarding the RTP packets on QUIC datagrams.\r\n",
          "createdAt": "2022-09-30T07:51:16Z",
          "updatedAt": "2022-09-30T07:51:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5Ct9xS",
          "commit": {
            "abbreviatedOid": "ae86df3"
          },
          "author": "aboba",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "\"the translator either may need to rewrite\"\r\n\r\n[BA] Can we delete the \"either\"?  Also, you might want to clarify that you are referring to a \"transport translator\" that could need codec-specific knowledge to do the packetization from frame/stream to datagram transport. \r\n\r\nWhat happens if a translator receives a RESET_STREAM frame?  Is it still required to do a graceful close?  Maybe just require the translator to echo the behavior that it sees (e.g. if it receives a graceful close, then send one, if it receives a RESET_STREAM, then send that along, unless it is forwarding datagrams). \r\n\r\n",
          "createdAt": "2022-09-24T21:54:03Z",
          "updatedAt": "2022-09-24T21:55:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOFUmh7s5A6nIu",
      "title": "Add length field and allow multiple packets per stream",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/43",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-17T10:15:36Z",
      "updatedAt": "2022-10-24T15:03:44Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "651d67471b525e2343e7a2d9e9fa08fc35070e97",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "length-field",
      "headRefOid": "410ae215371184370dc8a719a7a21e9540857640",
      "closedAt": "2022-10-24T15:03:43Z",
      "mergedAt": "2022-10-24T15:03:43Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d562b3b4786f7cf566efab3afa98bc27156dd2a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "PR_kwDOFUmh7s5A6v0x",
      "title": "Allow mixing of streams and datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/44",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-17T10:43:59Z",
      "updatedAt": "2022-10-24T14:30:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "mix-streams-and-datagrams",
      "headRefOid": "8202836850710f6992d18848f678b2bc50cfe22e",
      "closedAt": "2022-10-24T14:30:03Z",
      "mergedAt": "2022-10-24T14:30:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "dd403df25b65ac476b981d57210909f21205be70"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 46,
      "id": "PR_kwDOFUmh7s5CIK_j",
      "title": "WIP: Rely on WebTransport for multiplexing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/46",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This PR is a first draft to integrate WebTransport as an abstraction layer on top of QUIC to provide multiplexing.",
      "createdAt": "2022-11-03T11:13:02Z",
      "updatedAt": "2023-05-11T16:09:50Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/webtransport-multiplexing",
      "headRefOid": "5c2551fc826b227e7a0c3be5e3a87907b7763209",
      "closedAt": "2022-12-21T15:28:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOFUmh7s5F96PE",
      "title": "Add new multiplexing subsection using flow IDs",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/54",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-12-21T15:28:28Z",
      "updatedAt": "2023-01-17T09:58:26Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/flow-id-multiplexing",
      "headRefOid": "b24f20edd9f04e668ee0a6c43f47b2c680f0dcdf",
      "closedAt": "2023-01-17T09:58:25Z",
      "mergedAt": "2023-01-17T09:58:25Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "99a1494c2c913bd234bb77016e89d30e09e35aa2"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Has been proposed on mailing list. Question from @aboba, discussed with @mengelbart. OK to merge. ",
          "createdAt": "2023-01-13T16:08:31Z",
          "updatedAt": "2023-01-13T16:08:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDOFUmh7s5HT6_A",
      "title": "Clarify highest sequence number mapping",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/56",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-13T09:04:45Z",
      "updatedAt": "2023-05-11T16:09:55Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/highest-sequence-nr",
      "headRefOid": "842c0164f9ec95191056e4ff2a9c9098b6b64e86",
      "closedAt": "2023-01-23T15:19:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Included in #60 ",
          "createdAt": "2023-01-23T15:19:31Z",
          "updatedAt": "2023-01-23T15:19:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOFUmh7s5HT7Kg",
      "title": "Generalize which packets should be included",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/57",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "RTP packets can now also be sent in streams, thus it makes sense to say RTP packet (which could be in a datagram or stream) instead of datagram frame here.",
      "createdAt": "2023-01-13T09:05:24Z",
      "updatedAt": "2023-05-11T16:09:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/fraction-lost",
      "headRefOid": "d0e586ee6465509d6b42aa5081d3fc073c556502",
      "closedAt": "2023-01-17T09:39:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Will be solved in #60 ",
          "createdAt": "2023-01-17T09:39:57Z",
          "updatedAt": "2023-01-17T09:39:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOFUmh7s5HgED1",
      "title": "Address many/most of comments from @goelvidhi",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/60",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "This should be worth reviewing now, while I work on larger topics. \r\n\r\nComments and corrections are graciously welcomed. \r\n\r\nfixes #53 ",
      "createdAt": "2023-01-16T23:11:21Z",
      "updatedAt": "2023-01-23T15:51:33Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "99a1494c2c913bd234bb77016e89d30e09e35aa2",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "53-comments",
      "headRefOid": "d5f3d0f52256b01f836aee3fc21876e0ffc22c28",
      "closedAt": "2023-01-23T15:51:32Z",
      "mergedAt": "2023-01-23T15:51:32Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "3aae64deaee45942de470598192db9a44e8b063a"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I have a couple of open questions in the comments on this PR for you - do you think this PR is ready to commit, so we can focus on more specific issues (some of which I've opened in the last day or two)?",
          "createdAt": "2023-01-20T17:22:53Z",
          "updatedAt": "2023-01-20T17:22:53Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks, @SpencerDawkins! I think I replied to all questions, and I think we can discuss the congestion control vs. rate adaptation question in #61, and we can merge this PR.",
          "createdAt": "2023-01-23T15:25:22Z",
          "updatedAt": "2023-01-23T15:25:22Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I found one typo, and corrected it. I'm merging now. ",
          "createdAt": "2023-01-23T15:51:05Z",
          "updatedAt": "2023-01-23T15:51:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5KkxGZ",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-17T09:03:46Z",
          "updatedAt": "2023-01-17T09:38:38Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "additional",
              "createdAt": "2023-01-17T09:03:46Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 134,
              "body": "Should we also reference [Section 6 of RFC 9002](https://www.rfc-editor.org/rfc/rfc9002.html#section-6) here?\r\n```suggestion\r\n    but can detect lost packets based on the Gap numbers contained in QUIC ACK frames {{Section 6 of !RFC9002}}.\r\n```",
              "createdAt": "2023-01-17T09:20:20Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 169,
              "body": "```suggestion\r\nfor QUIC is an alogrithm similar to TCP NewReno {{!RFC9002}}, but senders are free to choose\r\n```\r\n`!` makes it a normative reference, `?` for informative.",
              "createdAt": "2023-01-17T09:22:16Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 108,
              "body": "```suggestion\r\n    packets that were sent after the RTP packet, were already acknowledged.\r\n```\r\n\r\nIn streams, the RTP packet can be spread over many frames.",
              "createdAt": "2023-01-17T09:29:01Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 116,
              "body": "In another PR I added some more text to explain what the highest sequence number is in RTP:\r\n```\r\n  * Highest Sequence Number received*: In RTCP, this field is a 32-bit field\r\n    that contains the highest sequence number a receiver received in an RTP\r\n    packet and the count of sequence number cycles the receiver has observed. A\r\n    sender sends RTP packets in QUIC packets and receives acknowledgments for\r\n    the QUIC packets. By keeping a mapping from a QUIC packet to the RTP packets\r\n    encapsulated in that QUIC packet, the sender can infer the highest sequence\r\n    number and number of cycles seen by the receiver from QUIC acknowledgments.\r\n```\r\n\r\nDoes it make sense to add this explanation, and if yes, should we add it to this PR?",
              "createdAt": "2023-01-17T09:38:21Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5KqgK3",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T00:28:43Z",
          "updatedAt": "2023-01-18T00:28:44Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "I think we should add this explanation. (Whether it is done here or in a separate PR, authors can decide that.)",
              "createdAt": "2023-01-18T00:28:43Z",
              "updatedAt": "2023-01-18T00:28:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5Kqgf6",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T00:30:51Z",
          "updatedAt": "2023-01-18T00:30:51Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "This reference and text is confusing. The text says TCP Reno but then it refers to QUIC Reno. I would just change this to, `The default congestion control specified for QUIC is Reno {{!RFC 9002}}`",
              "createdAt": "2023-01-18T00:30:51Z",
              "updatedAt": "2023-01-18T00:30:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5KqgnW",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T00:31:35Z",
          "updatedAt": "2023-01-18T00:31:35Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "replace congestion control with rate adaptation?",
              "createdAt": "2023-01-18T00:31:35Z",
              "updatedAt": "2023-01-18T00:31:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LN3NV",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T14:32:20Z",
          "updatedAt": "2023-01-19T14:32:20Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Corrected.",
              "createdAt": "2023-01-19T14:32:20Z",
              "updatedAt": "2023-01-19T14:32:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LOIUL",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T15:07:43Z",
          "updatedAt": "2023-01-19T15:07:43Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "@goelvidhi is right - this text/reference **is** scrambled. My thoughts are\r\n\r\n- TCP NewReno is [RFC6582]\r\n- the default QUIC congestion controller is [RFC9002] \r\n- [RFC9002] says \r\n> This document specifies a sender-side congestion controller for QUIC similar to TCP NewReno [RFC6582].\r\n\r\nSo, putting all this together, I get \r\n\r\n> The default congestion control specified for QUIC in {{RFC9002}} is similar to TCP NewReno {{RFC6582}}\r\n\r\nwhich (IIUC) gives the references for QUIC's default congestion controller and TCP NewReno correctly. \r\n\r\nPlease let me know if this is a Really Bad Idea.",
              "createdAt": "2023-01-19T15:07:43Z",
              "updatedAt": "2023-01-19T15:07:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LOJbh",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T15:10:08Z",
          "updatedAt": "2023-01-19T15:10:08Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "Fixed. ",
              "createdAt": "2023-01-19T15:10:08Z",
              "updatedAt": "2023-01-19T15:10:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LOPJC",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T15:22:17Z",
          "updatedAt": "2023-01-19T15:22:18Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "@mengelbart, I agree with @goelvidhi about adding this text. I put it in #60, so if it's also in another PR (which I haven't looked for yet), that should also be fine. ",
              "createdAt": "2023-01-19T15:22:18Z",
              "updatedAt": "2023-01-19T15:22:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LVlVc",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-20T16:21:26Z",
          "updatedAt": "2023-01-20T16:21:27Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "This is, of course, going to be maximally confusing to the reader, because RFC 8888 **says** it's enabling congestion control, but I think this is a good change to make for consistency in RTP-over-QUIC. \r\n\r\nLooking more closely at this text, RFC 8888 isn't technically part of \"RTP\", because it doesn't update any other RFC, so I think this is more accurate: \r\n\r\n> RTP itself does not specify a congestion control algorithm, but {{!RFC8888}} defines an RTCP\r\n> feedback message intended to enable rate adaptation for interactive real-time traffic using RTP,\r\n> and successful rate adaptation will accomoplish congestion control as well.\r\n> Various rate adaptation algorithms for real-time media are defined in separate RFCs\r\n> (e.g. SCReAM {{!RFC8298}} and NADA {{!RFC8698}}).\r\n\r\nAnd, looking more closely at the Abstract and Introduction, I think I should be naming both congestion control and rate adaptation in both places, and then favoring the use of rate adaptation thereafter. \r\n\r\nPlease let me know if this seems wrong or unhelpful. ",
              "createdAt": "2023-01-20T16:21:26Z",
              "updatedAt": "2023-01-20T16:21:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LckYt",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T15:11:11Z",
          "updatedAt": "2023-01-23T15:11:11Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Sounds good to me.",
              "createdAt": "2023-01-23T15:11:11Z",
              "updatedAt": "2023-01-23T15:11:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5Lcn1Z",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T15:18:46Z",
          "updatedAt": "2023-01-23T15:18:46Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Sounds mostly fine to me, but I wonder if we need the part \"and successful rate adaptation will accomoplish congestion control as well.\"? I think it might bring up the question of how exactly we define both and what the difference is.",
              "createdAt": "2023-01-23T15:18:46Z",
              "updatedAt": "2023-01-23T15:18:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LcpEK",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T15:21:24Z",
          "updatedAt": "2023-01-23T15:21:24Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Oh, I just saw #61 is about this question. If we have some text early in the document that defines both terms, the question might have been answered already.",
              "createdAt": "2023-01-23T15:21:24Z",
              "updatedAt": "2023-01-23T15:21:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOFUmh7s5JzKQ7",
      "title": "Add Scoping description for Abstract and Introduction",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/63",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "First draft of updated Abstract and Introduction sections.\r\n\r\nObviously a close read from reviewers will be useful, but I'd especially call attention to whether the abstract and first part of the Introduction correctly summarize the document (my impression is that the scope of the document has increased over time, but the abstract and Introduction might not have captured the new scope). \r\n\r\nCloses #58.",
      "createdAt": "2023-02-12T19:38:03Z",
      "updatedAt": "2023-02-20T08:46:25Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2853821a8d8d121809381041786178157c36863e",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-58",
      "headRefOid": "503d7fea280f75eddf319589da78ac46f1742e83",
      "closedAt": "2023-02-20T08:46:24Z",
      "mergedAt": "2023-02-20T08:46:24Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "157005404bf8dcf5b7cfd0305e8379454bdadd24"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5NMohN",
          "commit": {
            "abbreviatedOid": "8a01814"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-13T08:39:47Z",
          "updatedAt": "2023-02-13T08:42:22Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nThis document does not cover signaling for session setup. SDP for RTP-over-QUIC is defined in separate documents such as {{?I-D.draft-dawkins-avtcore-sdp-rtp-quic}}, and can be carried in any signaling protocol that can carry SDP, including the Session Initiation Protocol (SIP) ({{?RFC3261}}), Real-Time Protocols for Browser-Based Applications (RTCWeb) ({{?RFC8825}}), or WebRTC-HTTP Ingestion Protocol (WHIP) ({{?I-D.draft-ietf-wish-whip}}).\r\n```",
              "createdAt": "2023-02-13T08:39:47Z",
              "updatedAt": "2023-02-13T08:42:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOFUmh7s5Jzl0X",
      "title": "First draft of definitions for congestion control and rate adaptation",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/64",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "This is a starting place for several related issues (#61, #62, and #59). \r\n\r\nCloses #61 ",
      "createdAt": "2023-02-13T02:12:34Z",
      "updatedAt": "2023-02-20T08:25:15Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3aae64deaee45942de470598192db9a44e8b063a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-61",
      "headRefOid": "38208ae4366856d8af03d9a25f65763e1936d712",
      "closedAt": "2023-02-20T08:25:13Z",
      "mergedAt": "2023-02-20T08:25:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2853821a8d8d121809381041786178157c36863e"
      },
      "comments": [
        {
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "body": "The above definitions state that rate adaptation is \"distinct\" from congestion control. But the distinction mentioned only covers the case in which one choose across multiple media flows and some aggregate congestion control can be performed. This appears to be a special case. Rate adaptation is generally one way to achieve congestion control, it would seem, and maybe in some cases the only one. Needs more thinking.",
          "createdAt": "2023-02-17T13:11:19Z",
          "updatedAt": "2023-02-17T13:11:19Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> The above definitions state that rate adaptation is \"distinct\" from congestion control. But the distinction mentioned only covers the case in which one choose across multiple media flows and some aggregate congestion control can be performed. This appears to be a special case. Rate adaptation is generally one way to achieve congestion control, it would seem, and maybe in some cases the only one. Needs more thinking.\r\n\r\n@joerg-ott, I agree. I've rephrased this in my latest commit. \r\n\r\nWe will definitely need more thinking here - I see that Christian @Huitema has a [specific proposal for congestion response in MOQ](https://mailarchive.ietf.org/arch/msg/moq/sWDaR6lRu3tBLOvHkth-sipbf4Q/). That may not be directly applicable to RTP-over-QUIC, but it's a good example of the kind of this we should also consider in your draft. \r\n\r\nBut given that we have other issues for adding specific descriptions of rate control and this PR only targeted adding definitions, I think this PR is ready to merge. ",
          "createdAt": "2023-02-19T13:12:17Z",
          "updatedAt": "2023-02-19T13:12:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 66,
      "id": "PR_kwDOFUmh7s5KSPO6",
      "title": "Adding ACKs for Bernard and Sergio",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/66",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-19T13:29:48Z",
      "updatedAt": "2023-02-20T08:24:09Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3aae64deaee45942de470598192db9a44e8b063a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-55",
      "headRefOid": "1f5c8ac696100a566e47b2a7e193111c813309fc",
      "closedAt": "2023-02-20T08:24:08Z",
      "mergedAt": "2023-02-20T08:24:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "05e5c1ba8f73d9d397a8d0b44ffec761690eaa60"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "PR_kwDOFUmh7s5M78fH",
      "title": "Add @mengelbart RTCP analysis",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/71",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "It is likely that these new sections/tables need to be more carefully integrated into the previous text on RTCP. \r\n\r\nclose #48 ",
      "createdAt": "2023-03-27T05:55:49Z",
      "updatedAt": "2023-04-27T07:05:41Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "157005404bf8dcf5b7cfd0305e8379454bdadd24",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-48",
      "headRefOid": "426ca2b6c2d9de95f505db7f341063641214d73a",
      "closedAt": "2023-04-27T07:05:40Z",
      "mergedAt": "2023-04-27T07:05:40Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3624f2fa943fa8b7c8f491d36c908525e0b8ed32"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We should add \"header extensions\" to the section title (@SpencerDawkins agrees). ",
          "createdAt": "2023-04-19T17:04:42Z",
          "updatedAt": "2023-04-19T17:04:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I still need to work on Section 6.3. RTCP Control Packet Types - several of these packet types have \"\"partly\" or \"possibly\" under \"replaced by QUIC\", because they have multiple reports, and the answer to \"replaced by QUIC\" varies among the reports. My plan is to break those cases into one row per report, so the ability to map to/from QUIC is clearer. \r\n\r\nI don't think that will take long, but I think we should wait to merge until I can finish that. ",
          "createdAt": "2023-04-25T00:41:09Z",
          "updatedAt": "2023-04-25T00:41:09Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I think it's OK for us to merge this PR. There's still more analysis to do, but I'd like to land this PR and work on a couple of issues that I still haven't touched. ",
          "createdAt": "2023-04-26T23:28:11Z",
          "updatedAt": "2023-04-26T23:28:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5SlRpS",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Some of the information in the new tables in sections 6.3 and 6.4 duplicates what is written in sections 6.1 and 6.2. It could be helpful to have subsections for the details of each packet type and then reference the subsection from the tables. That would also make the tables easier to read.",
          "createdAt": "2023-04-14T13:51:44Z",
          "updatedAt": "2023-04-14T16:16:41Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Should we rename the section from just *RTCP* to *RTCP and RTP Header Extensions* if we add the subsection on header extensions?",
              "createdAt": "2023-04-14T13:51:44Z",
              "updatedAt": "2023-04-14T16:16:41Z"
            },
            {
              "originalPosition": 85,
              "body": "This table contains only *no*s and does not add anything that cannot be found in the IANA registry. I think we can replace it with a more general statement that payload-specific feedback types are not suitable to be replaced by the QUIC state.",
              "createdAt": "2023-04-14T13:54:39Z",
              "updatedAt": "2023-04-14T16:16:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5TGKMY",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T14:22:54Z",
          "updatedAt": "2023-04-20T14:22:54Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I agree. I'm making this change. ",
              "createdAt": "2023-04-20T14:22:54Z",
              "updatedAt": "2023-04-20T14:22:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5TGVb4",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T14:41:54Z",
          "updatedAt": "2023-04-20T14:41:54Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think this is a good suggestion - I added \"Because QUIC is a generic transport protocol, QUIC cannot replace the following Payload-specific RTP Feedback (PSFB) feedback\" at the beginning of the section, but I left the list of feedback types and their documents in the text, just to make what we considered, clear to the reader. \r\n\r\nDoes that make sense?",
              "createdAt": "2023-04-20T14:41:54Z",
              "updatedAt": "2023-04-20T14:41:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5TpFvt",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T06:27:27Z",
          "updatedAt": "2023-04-27T06:27:28Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Yes, that sounds good. Thanks!",
              "createdAt": "2023-04-27T06:27:27Z",
              "updatedAt": "2023-04-27T06:27:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOFUmh7s5M8bB2",
      "title": "Add details on supported topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/72",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Note: we have introduced a MUST in this PR, so the guidance isn't entirely \"informational\". \r\n\r\ncloses #47 ",
      "createdAt": "2023-03-27T07:43:47Z",
      "updatedAt": "2023-04-27T06:26:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "157005404bf8dcf5b7cfd0305e8379454bdadd24",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-47",
      "headRefOid": "e7f6496014e9f0f08c26a187b2be2c8317d96bec",
      "closedAt": "2023-04-27T06:26:03Z",
      "mergedAt": "2023-04-27T06:26:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "7271014e241950bafb3a8982decd7aacb3963c42"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We're assuming that each topology is considered on its own. If (for example) Topo-Media-Translator  is also doing Topo-Trn-Translator, look at both rows in the table. But we note that with Topo-Back-To-Back, all bets are off ... ",
          "createdAt": "2023-04-19T16:33:21Z",
          "updatedAt": "2023-04-19T16:33:21Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I think this PR is ready to merge. ",
          "createdAt": "2023-04-20T14:13:16Z",
          "updatedAt": "2023-04-20T14:13:16Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - this is definitely ready to merge now. ",
          "createdAt": "2023-04-26T23:35:20Z",
          "updatedAt": "2023-04-26T23:35:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5SmTHO",
          "commit": {
            "abbreviatedOid": "a43ccbf"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "In my local rendering, the notes get squeezed into the table with very narrow columns, which makes it hard to read. Is there a better format we could use instead of a table, or maybe we could replace the footnotes with subsections that we can reference from the table?",
          "createdAt": "2023-04-14T16:19:53Z",
          "updatedAt": "2023-04-14T16:22:46Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Should we add this to the security considerations as well?",
              "createdAt": "2023-04-14T16:19:54Z",
              "updatedAt": "2023-04-14T16:22:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5Tc41b",
          "commit": {
            "abbreviatedOid": "aa52f1d"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-25T14:40:53Z",
          "updatedAt": "2023-04-25T14:40:54Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I think this was meant to say *Burst Source* instead of *Distribution Source*. But I just re-read the text about SSM in RFC 7667, and I think we can actually drop this last part of the sentence here and also for `Note-UCast-Mcast`. I don't know why I thought *Distribution Source* and *Burst Source* could just be *logical entities*. The text says:\r\n\r\n> These sources send media to a dedicated Distribution Source, which forwards the RTP streams to the multicast group on behalf of the original RTP sources.\r\n\r\nSorry, I didn't catch that earlier!",
              "createdAt": "2023-04-25T14:40:54Z",
              "updatedAt": "2023-04-25T14:40:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOFUmh7s5M8pTo",
      "title": "Add additional congestion control-related terms and definitions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/73",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #70 ",
      "createdAt": "2023-03-27T08:25:04Z",
      "updatedAt": "2023-04-14T12:25:00Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "157005404bf8dcf5b7cfd0305e8379454bdadd24",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-70",
      "headRefOid": "9b7247c9bc3738b0a363c611f051fef3989db13e",
      "closedAt": "2023-04-14T12:24:58Z",
      "mergedAt": "2023-04-14T12:24:58Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "428885d6e5ea8ed92e2feb21597758813aae42bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5Q-zjV",
          "commit": {
            "abbreviatedOid": "9b7247c"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-27T08:51:59Z",
          "updatedAt": "2023-03-27T08:51:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOFUmh7s5OV3Nh",
      "title": "Replace \"RTP over QUIC\" with RoQ acronym",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/78",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #74 ",
      "createdAt": "2023-04-14T16:05:25Z",
      "updatedAt": "2023-04-27T07:14:14Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3624f2fa943fa8b7c8f491d36c908525e0b8ed32",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/acronym-roq",
      "headRefOid": "6db9f03a13d5a47b5091b7026cffc898db1206f4",
      "closedAt": "2023-04-27T07:14:13Z",
      "mergedAt": "2023-04-27T07:14:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "037be428ba688e19be178587a26b5fdce617b11b"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> Definitely - do it!\r\n> \r\n> One question - merging this won't update the text I have in my PRs. Do you think it will be easier to resolve conflicts if you merge this one first? If so, DEFINITELY - do it!\r\n> \r\n> If not, please let me know, and I'll work on rebasing my PRs (or whatever the right answer is).\r\n\r\nMerging the PRs first and now rebasing and updating this one was easier, so no need to change anything in your PRs :) Will merge this now, too.",
          "createdAt": "2023-04-27T07:14:01Z",
          "updatedAt": "2023-04-27T07:14:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5TlcJx",
          "commit": {
            "abbreviatedOid": "312aa0a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Definitely - do it! \r\n\r\nOne question - merging this won't update the text I have in my PRs. Do you think it will be easier to resolve conflicts if you merge this one first? If so, DEFINITELY - do it!\r\n\r\nIf not, please let me know, and I'll work on rebasing my PRs (or whatever the right answer is).",
          "createdAt": "2023-04-26T16:00:23Z",
          "updatedAt": "2023-04-26T16:00:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOFUmh7s5P017x",
      "title": "Explain why we aren't making BCP recommendations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/81",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "@aboba, thank you for the example in your comment on #69. That was helpful. \r\n\r\nclose #69",
      "createdAt": "2023-05-05T02:13:32Z",
      "updatedAt": "2023-05-11T07:49:34Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "037be428ba688e19be178587a26b5fdce617b11b",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-69",
      "headRefOid": "7d49c6f61c8242462ca2d721c4725afd39d0af25",
      "closedAt": "2023-05-11T07:49:33Z",
      "mergedAt": "2023-05-11T07:49:33Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0f0023698f38b71e15fdc964c87a9cf58c5407d8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5UrQU8",
          "commit": {
            "abbreviatedOid": "7d49c6f"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-10T13:17:29Z",
          "updatedAt": "2023-05-10T13:17:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOFUmh7s5P1CSN",
      "title": "Provide guidance for coexisting control loops",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/83",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "I want to provide a bit more description of GCC and classic response to packet loss, but I'm happy to get feedback on what I've committed so far. \r\n\r\nclose #59 ",
      "createdAt": "2023-05-05T03:51:40Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ce5bf21aa30f3790040352c3e84942c199bc1780",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-59",
      "headRefOid": "e052610a0d9510c6f5fd2a0e50438f3d8a886649",
      "closedAt": "2023-05-16T20:24:55Z",
      "mergedAt": "2023-05-16T20:24:54Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8dbb4db2bb1c951a00b4bb871ff94d2f809c7022"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @joerg-ott -\r\n\r\n> I want to provide a bit more description of GCC and classic response to packet loss, but I'm happy to get feedback on what I've committed so far.\r\n\r\nI've now done so, and I think this PR is ready for review. ",
          "createdAt": "2023-05-05T17:46:29Z",
          "updatedAt": "2023-05-05T17:46:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I corrected the spelling error and replied to the comment about GCC. If you think we need to discuss the GCC comment for a bit, please let me know, otherwise this PR should be ready to merge. ",
          "createdAt": "2023-05-11T01:11:07Z",
          "updatedAt": "2023-05-11T01:11:07Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @mengelbart - I worked over Section 7.4, but have one question that you're more likely to know the answer to than I am. \r\n\r\nFor the flow identifier described in the multiplexing section, I see \r\n\r\n>Each flow identifier is associated with a _stream of RTP packets_, _RTCP packets_, or a _data stream of a non-RTP protocol_\r\n\r\nIf I am **_using datagrams to carry multiple channels between two RTP endpoints_**, do we ALSO use this flow identifier to disambiguate (say) the datagrams carrying video, left-side audio, and right-side audio over the same QUIC connection?",
          "createdAt": "2023-05-12T15:47:11Z",
          "updatedAt": "2023-05-12T15:47:11Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I would expect the datagrams of the different channels to use different flow identifiers unless you send them in the same RTP session, which would require some other form of multiplexing, e.g., [RFC 8860](https://www.rfc-editor.org/rfc/rfc8860). The multiplexing section allows both, so we could use the flow identifier to disambiguate the datagrams, but we could also use the same identifier for more than one channel as long as we can still demultiplex them on the receiver side.",
          "createdAt": "2023-05-12T16:50:42Z",
          "updatedAt": "2023-05-12T16:50:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart, \r\n\r\n> I would expect the datagrams of the different channels to use different flow identifiers unless you send them in the same RTP session, which would require some other form of multiplexing, e.g., [RFC 8860](https://www.rfc-editor.org/rfc/rfc8860). The multiplexing section allows both, so we could use the flow identifier to disambiguate the datagrams, but we could also use the same identifier for more than one channel as long as we can still demultiplex them on the receiver side.\r\n\r\nIt's multiplexing all the way down, isn't it? Like \"[turtles all the way down](https://en.wikipedia.org/wiki/Turtles_all_the_way_down#:~:text=The%20saying%20alludes%20to%20the,larger%20turtles%20that%20continues%20indefinitely.)\". \r\n\r\n- I do want to check whether there's a list of levels of multiplexing in the draft, because that would be helpful, but \r\n- I want even more to make sure there's a list, where we can put a reference to the World Turtle. :grinning:",
          "createdAt": "2023-05-16T13:02:59Z",
          "updatedAt": "2023-05-16T13:02:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "There is [RFC 8872](https://datatracker.ietf.org/doc/html/rfc8872), which might help. We'd also need to reference the multiplexing section where the flow ID is explained. And maybe we should add a reference to 8872 in that section...",
          "createdAt": "2023-05-16T13:28:12Z",
          "updatedAt": "2023-05-16T13:28:12Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I just noticed this text in 8.2: \r\n\r\n> Disable Congestion Controller: If congestion control is to be implemented at the application layer as described in Section 7.2, and the application layer is trusted to apply adequate congestion control as described in Section 7 of [RFC9002] and Section 3.1 of [RFC8085], **it is RECOMMENDED to allow the application to disable QUIC layer congestion control entirely.**\r\n\r\nI need to remove this mention of disabling QUIC layer congestion control before we merge the PR. ",
          "createdAt": "2023-05-16T15:59:26Z",
          "updatedAt": "2023-05-16T15:59:26Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We'll add this reference and RFC 8872 in another PR. \r\n\r\n> I would expect the datagrams of the different channels to use different flow identifiers unless you send them in the same RTP session, which would require some other form of multiplexing, e.g., [RFC 8860](https://www.rfc-editor.org/rfc/rfc8860). The multiplexing section allows both, so we could use the flow identifier to disambiguate the datagrams, but we could also use the same identifier for more than one channel as long as we can still demultiplex them on the receiver side.\r\n\r\n",
          "createdAt": "2023-05-16T16:50:26Z",
          "updatedAt": "2023-05-16T16:50:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5UrUXN",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T13:25:29Z",
          "updatedAt": "2023-05-10T13:28:36Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "If this is a normative reference, would it be helpful to reference NADA or SCReAM instead of the GC draft?",
              "createdAt": "2023-05-10T13:25:29Z",
              "updatedAt": "2023-05-10T13:28:36Z"
            },
            {
              "originalPosition": 92,
              "body": "`mazimizing` -> `maximizing`",
              "createdAt": "2023-05-10T13:28:22Z",
              "updatedAt": "2023-05-10T13:28:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5UuzxQ",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T00:56:07Z",
          "updatedAt": "2023-05-11T00:56:07Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "This is a reasonable question. I think the answer is that GCC targets transport protocols that are not aware that they are carrying media, while NADA and SCReAM target RTP applications that are aware they are performing rate adaptation for media, so the thing to do in this transport protocol section, is to cite GCC.\r\n\r\nDoes that make sense?",
              "createdAt": "2023-05-11T00:56:07Z",
              "updatedAt": "2023-05-11T00:56:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5UwVRV",
          "commit": {
            "abbreviatedOid": "519846f"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T07:48:52Z",
          "updatedAt": "2023-05-11T07:48:53Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "To me, all three seem to target RTP applications, and the GCC draft references multiple RTP header extensions and RTCP feedback messages which were explicitly designed for GCC.\r\n\r\nAnother alternative to mention could be BBR. However, I don't know if that is a good recommendation for media. I think it has been mentioned somewhere that BBRs probing phases are problematic for real-time media.\r\n\r\nBBR also (still?) seems to be a draft, so we might not want to use it as a normative reference, either. I think we have this problem with other references, too, but I'd like to avoid adding more normative references to draft documents if possible (at least if the documents are expired and don't seem to be actively developed any longer). Regardless of which algorithm we reference here, does the reference have to be normative?",
              "createdAt": "2023-05-11T07:48:52Z",
              "updatedAt": "2023-05-11T07:48:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5U1UW3",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T19:06:25Z",
          "updatedAt": "2023-05-11T19:06:25Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "@mengelbart - I'm replying here, just to preserve our helpful discussion which was also happening in Slack. Here's what I've got, point by point. \r\n\r\n> To me, all three seem to target RTP applications, and the GCC draft references multiple RTP header extensions and RTCP feedback messages which were explicitly designed for GCC.\r\n\r\nI think we're struggling a bit, because the draft is not internally consistent (yet) - for example, if we are writing a specification that assumes QUIC implementations know that our packets are media (perhaps because the connection uses rtp-mux-quic as its ALPN, rather than h3, or some other non-media ALPN), that's different from assuming that QUIC implementations don't know that our packets are media, and have to use a congestion controller-rate adapter that works for any packets, without special knowledge. \r\n\r\nAs I said in SLACK, if we CAN have real-time and non-real-time packets in the same QUIC connection, that has different implications. So, we need to be looking for inconsistencies. \r\n\r\n> Another alternative to mention could be BBR. However, I don't know if that is a good recommendation for media. I think it has been mentioned somewhere that BBRs probing phases are problematic for real-time media.\r\n\r\nYes, exactly. The idea is that any probing congestion controller probes by sending \"more data than it did the last RTT\", until it detects increasing delay, or actual packet loss. If the media congestion controller doesn't need to probe for bandwidth, or doesn't do that often, the media traffic won't experience increasing delays or packet loss. \r\n\r\n> BBR also (still?) seems to be a draft, so we might not want to use it as a normative reference, either. I think we have this problem with other references, too, but I'd like to avoid adding more normative references to draft documents if possible (at least if the documents are expired and don't seem to be actively developed any longer). Regardless of which algorithm we reference here, does the reference have to be normative?\r\n\r\nRight. So the point for normative references is that people must have access to them, to implement YOUR specification. What I THINK we are doing, is to say \"use a media-centric rate adaptation mechanism, and here are three that could meet your needs\". IMO, all three of these are informational, not normative (because you don't have to read any of them, you just need to understand what makes a rate adaptation mechanism media-centric). \r\n\r\nIf you think it would help, we can add [RFC 8836 Congestion Control Requirements for Interactive Real-Time Media](https://www.rfc-editor.org/rfc/rfc8836.html). I'm still not convinced that would be normative, but it might be helpful to the reader. \r\n\r\nGot any thoughts about any of this? I'll be typing, but I'm happy to be corrected, especially while I haven't merged any of this into Main yet!\r\n",
              "createdAt": "2023-05-11T19:06:25Z",
              "updatedAt": "2023-05-11T19:06:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5U1exg",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T19:38:19Z",
          "updatedAt": "2023-05-11T19:38:19Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "That all makes sense. \r\n\r\n> I think we're struggling a bit, because the draft is not internally consistent (yet) - for example, if we are writing a specification that assumes QUIC implementations know that our packets are media (perhaps because the connection uses rtp-mux-quic as its ALPN, rather than h3, or some other non-media ALPN), that's different from assuming that QUIC implementations don't know that our packets are media, and have to use a congestion controller-rate adapter that works for any packets, without special knowledge.\r\n\r\nI think that's why we use `RECOMMEND` above. We don't know if the QUIC stack is aware of what is being sent over it and if the application has any control over the congestion control used in the QUIC stack. If the app is in control, we know what is being sent and can decide to use real-time CC. We can't do much if neither the app can choose a congestion controller nor the QUIC stack knows about the payload.\r\n\r\n> As I said in SLACK, if we CAN have real-time and non-real-time packets in the same QUIC connection, that has different implications. So, we need to be looking for inconsistencies.\r\n\r\nAgree. I think we should add more clarification to section 7.4 about the implications for congestion control when sharing a connection between real-time and non-real-time streams.\r\n\r\n> IMO, all three of these are informational, not normative (because you don't have to read any of them, you just need to understand what makes a rate adaptation mechanism media-centric).\r\n\r\nHaving an informational reference to any of the three algorithms should be fine, I think :) And adding a reference to RFC 8836 also sounds helpful. ",
              "createdAt": "2023-05-11T19:38:19Z",
              "updatedAt": "2023-05-11T19:38:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDOFUmh7s5QXrjy",
      "title": "Add considerations for STOP\\_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/88",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-12T09:31:23Z",
      "updatedAt": "2023-05-18T09:02:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "8dbb4db2bb1c951a00b4bb871ff94d2f809c7022",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/45/stop-sending",
      "headRefOid": "47913e23d69c6a1f3a19905ce5ff16ad631fe884",
      "closedAt": "2023-05-18T09:02:52Z",
      "mergedAt": "2023-05-18T09:02:52Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "9890c6fca2fd1ebea225c3f0127381007ccf532a"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "close #45 ",
          "createdAt": "2023-05-12T09:50:56Z",
          "updatedAt": "2023-05-12T09:52:04Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> The sending RTP application SHOULD not interpret the reception of STOP_SENDING as an indication that the receiver lost interest in the media stream as a whole, but rather that a part of the media stream was not received timely and some recovery is probably necessary.\r\n\r\nSounds good. I will change it.\r\n\r\n> I was confused here. Is this saying the (sending RTP application) MUST NOT retransmit media frames on the new stream, or MUST NOT retransmit QUIC frames on the new stream?\r\n\r\nThis should be media frames, I will add it to clarify. \r\n\r\n> Do we have a complete list of QUIC extension RFCs and drafts we think might be useful in ROQ? That would be a fine thing to add.\r\n\r\nThat is a good idea, I opened #92 ",
          "createdAt": "2023-05-16T15:26:44Z",
          "updatedAt": "2023-05-16T15:26:44Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I am not sure I understand your comment here:\r\n\r\n> I think (but could be wrong) that we are complicating our work by saying \"this is how ROQ works\", and then having to clarify that \"this is a QUIC streams thing (like STOP_SENDING), and the rules are different if you're using QUIC datagrams (as below), and (of course) it's legal for ROQ endpoints to use both\".\r\n> \r\n> But that's a question for another issue. On this issue ...\r\n\r\nWould you mind opening that issue?",
          "createdAt": "2023-05-16T15:29:18Z",
          "updatedAt": "2023-05-16T15:29:18Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Preferring \"RTP sender\", rather than \"sender\". ",
          "createdAt": "2023-05-16T16:19:51Z",
          "updatedAt": "2023-05-16T16:19:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am not sure I understand your comment here:\r\n> \r\n>> I think (but could be wrong) that we are complicating our work by saying \"this is how ROQ works\", and then having to clarify that \"this is a QUIC streams thing (like STOP_SENDING), and the rules are different if you're using QUIC datagrams (as below), and (of course) it's legal for ROQ endpoints to use both\".\r\n>>\r\n>> But that's a question for another issue. On this issue ...\r\n>\r\n> Would you mind opening that issue?\r\n\r\nLet's wait to think about this some more, but I'll open an issue for it when it becomes an issue. :grinning:",
          "createdAt": "2023-05-16T16:37:28Z",
          "updatedAt": "2023-05-16T16:37:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5VJ0n0",
          "commit": {
            "abbreviatedOid": "6dd350a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for working through the comments about this. \r\n\r\nI think (but could be wrong) that we are complicating our work by saying \"this is how ROQ works\", and then having to clarify that \"this is a QUIC streams thing (like STOP\\_SENDING), and the rules are different if you're using QUIC datagrams (as below), and (of course) it's legal for ROQ endpoints to use both\". \r\n\r\nBut that's a question for another issue. On **this issue** ... \r\n\r\n> QUIC allows an application to abort reading the stream and specify an error code\r\n> {{Section 3.5 of !RFC9000}}. The QUIC transport can signal this to the sending\r\n> side by sending a STOP\\_SENDING frame. The sender SHOULD not interpret the\r\n> reception of STOP\\_SENDING as an indication that the receiver lost interest in\r\n> the media stream as a whole, but rather that a part of the media stream was not\r\n> received timely and some recovery is necessary. \r\n\r\nHmmm. Is this a normative requirement on QUIC, beyond RFC 9000/RFC 9221? I think we might express this better as \r\n\r\nThe **sending RTP application** SHOULD not interpret the reception of STOP\\_SENDING as an indication that the receiver lost interest in the media stream as a whole, but rather that a part of the media stream was not received timely and some recovery **is probably** necessary.\r\n\r\n> The recovery may be supported by\r\n> dropping some parts of the media stream entirely and restarting to send new\r\n> media frames on new QUIC streams. While STOP\\_SENDING includes an error code, it\r\n> does not allow the receiving side to inform the sender where exactly it wishes\r\n> to restart receiving media. A sender that receives STOP\\_SENDING MUST NOT\r\n> transmit any frames already sent on the QUIC stream, on which STOP\\_SENDING was\r\n> received, on a new QUIC stream. \r\n\r\nI was confused here. Is this saying the (sending RTP application) MUST NOT retransmit **media** frames on the new stream, or MUST NOT retransmit QUIC frames on the new stream?\r\n\r\n> A sender SHOULD instead continue to send media\r\n> frames on new QUIC streams starting with the first frame that was not\r\n> transmitted on the stream that received STOP\\_SENDING.\r\n\r\nSkipping down to \r\n\r\n> **Editor's note:** A receiver cannot cancel a certain frame but still receive\r\n> retransmissions for a frame the was following on the same stream using\r\n> STOP\\_SENDING, because STOP\\_SENDING does not include an offset which would\r\n> allow signaling where retransmissions should continue. If this is a required\r\n> feature for RoQ, it could be implemented using an extended STOP\\_SENDING frame\r\n> as, for example, proposed in {{?I-D.draft-thomson-quic-enough-00}}\r\n\r\nDo we have a complete list of QUIC extension RFCs and drafts we think might be useful in ROQ? That would be a fine thing to add. ",
          "createdAt": "2023-05-16T13:51:21Z",
          "updatedAt": "2023-05-16T13:51:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 89,
      "id": "PR_kwDOFUmh7s5QZkdU",
      "title": "Add example for MAX_STREAMS and hint for signaling",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/89",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-12T15:41:55Z",
      "updatedAt": "2023-05-18T09:03:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0f0023698f38b71e15fdc964c87a9cf58c5407d8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/49/max-streams",
      "headRefOid": "6d1afac99e3b4ca70a916b5490f7db2f535b3f22",
      "closedAt": "2023-05-18T09:03:03Z",
      "mergedAt": "2023-05-18T09:03:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "6a957b4d1a504a3d647e30cb9948748c4ae37f56"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 90,
      "id": "PR_kwDOFUmh7s5Qf_Yy",
      "title": "Remove obsolete discussion about flow IDs",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/90",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Multiplexing was discussed at an interim meeting in december 2022 and on the mailing list and an extended section explaining multiplexing using flow IDs was added in PR #54.",
      "createdAt": "2023-05-15T10:49:36Z",
      "updatedAt": "2023-05-16T16:12:20Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0f0023698f38b71e15fdc964c87a9cf58c5407d8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/remove-flow-id-discussion",
      "headRefOid": "0b5c35d96982c643818ba2dc18c161dafa2eee8c",
      "closedAt": "2023-05-16T16:12:19Z",
      "mergedAt": "2023-05-16T16:12:19Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "ce5bf21aa30f3790040352c3e84942c199bc1780"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 91,
      "id": "PR_kwDOFUmh7s5QnZQg",
      "title": "Define error codes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/91",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Actual codes are still missing to avoid redefining them multiple times if we add more codes.",
      "createdAt": "2023-05-16T13:19:57Z",
      "updatedAt": "2023-07-22T22:38:57Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/76/error-codes",
      "headRefOid": "aef3eff6b75f3c9d4530fbc9ec74f0b6dc12375d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR has a starting point - next steps are \r\n\r\n- present to WG and ask for comments\r\n- add error codes to relevant sections of the draft",
          "createdAt": "2023-05-16T16:57:33Z",
          "updatedAt": "2023-05-16T16:57:33Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I added text to the rest of the draft to explain which error codes should be used. Some error codes are not yet mentioned in the text, and I am not sure if we really need them:\r\n\r\n* ROQ_GENERAL_PROTOCOL_ERROR\r\n* ROQ_INTERNAL_ERROR\r\n* ROQ_PACKET_ERROR\r\n\r\nIt may be enough to have one of them, or it may be helpful to have the option to be more specific.\r\n\r\n(The PR is now based on #98 and should only be merged after that PR is merged, too)",
          "createdAt": "2023-07-03T12:28:48Z",
          "updatedAt": "2023-07-03T12:28:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 94,
      "id": "PR_kwDOFUmh7s5Q0CDI",
      "title": "Moving RTCP replacement section below congestion control section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/94",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #82 \r\n\r\nI still wonder about moving the streams and datagrams subsections of what is now Section 7 out - they may have more to do with congestion control than replacing RTCP feedback. But we can merge this one, and then talk about additional editing that may be required. ",
      "createdAt": "2023-05-18T14:33:30Z",
      "updatedAt": "2023-05-18T18:33:30Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "6a957b4d1a504a3d647e30cb9948748c4ae37f56",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-82",
      "headRefOid": "9a457a1684744520fb055b10660f9bda71df20bd",
      "closedAt": "2023-05-18T18:33:29Z",
      "mergedAt": "2023-05-18T18:33:29Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5VbbBM",
          "commit": {
            "abbreviatedOid": "9a457a1"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-18T18:33:24Z",
          "updatedAt": "2023-05-18T18:33:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOFUmh7s5Q_R3C",
      "title": "Fix normative language about STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/96",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-22T08:12:43Z",
      "updatedAt": "2023-07-18T13:54:33Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/normative-language-stop-sending",
      "headRefOid": "2412b01b874d39560a4a519ae94250def296672c",
      "closedAt": "2023-07-10T16:38:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart is working on PR #98 which should replace this PR when it is merged. \r\n\r\nWe're not working on this PR further, so please look at #98 instead. ",
          "createdAt": "2023-06-16T15:14:35Z",
          "updatedAt": "2023-06-16T15:14:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5Vo1eP",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T14:28:50Z",
          "updatedAt": "2023-05-22T15:56:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I know this seems ridiculous, but \"SHOULD\" and \"SHOULD NOT\" are defined terms in BCP14, and \"SHOULD not\" is not. Although \"SHOULD not\" would be clear to many readers, it's not actual requirements language. :innocent:",
              "createdAt": "2023-05-22T14:28:50Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 20,
              "body": "This might be clearer as two sentences: \r\n\r\n\"In\r\nthis case, the late data could also delay **any** following media frames due to\r\nhead-of-line blocking **within a single QUIC stream**. The **RTP** sender can avoid these delays by transmitting new media\r\nframes on new QUIC streams.\" \r\n\r\nI put what seemed like significant changes in bold, so you could spot them more easily. Please let me know if I misunderstand your intended meaning. ",
              "createdAt": "2023-05-22T14:46:02Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 22,
              "body": "I made this more complicated than it needed to be. See if this is easier to understand. \r\n\r\n\"A QUIC sender that receives STOP\\_SENDING on a QUIC stream MUST NOT\r\nretransmit any media frames already sent on that QUIC stream, on any QUIC stream.\"",
              "createdAt": "2023-05-22T15:03:05Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 17,
              "body": "OK, this is super awkward. I think we've gotten confused about the difference between what a **QUIC receiver** thinks it means when it sends \"STOP\\_SENDING\", and what an **RTP receiver** thinks it means. \r\n\r\nFrom [RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-solicited-state-transitions): \r\n\r\n> If the stream is in the \"Recv\" or \"Size Known\" state, the transport SHOULD signal this by sending a STOP_SENDING frame to prompt closure of the stream in the opposite direction. This typically indicates that the receiving application is no longer reading data it receives from the stream, but it is not a guarantee that incoming data will be ignored.\r\n\r\nSo, it looks like the application HAS lost interest - because the media frames are arriving late enough that they are not useful. The application is sending \"STOP\\_SENDING\" to trigger an automatic \"RESET\\_STREAM\".\r\n\r\nWhat's confusing, is that the **RTP receiver** - the application - hasn't lost interest in the **media** - it's lost interest in **getting outdated and unusable media frames.** The RTP receiver wants the RTP sender to start over, with the most current media frames, on a stream that doesn't already hold additional outdated frames. \r\n\r\nDoes that make sense?\r\n\r\nAssuming so, the text in this part of the document should reflect that distinction. ",
              "createdAt": "2023-05-22T15:27:06Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 25,
              "body": "Are we mandating that RTP senders open a new stream and continue sending? \r\n\r\nIf we are, and a RTP receiver really has stopped caring about this RTP stream, how does it \"turn the RTP sender off\"? \r\n\r\nI think we're basically telling a RTP receiver that wants to \"skip forward to usable media frames\", to transmit a \"STOP\\_SENDING\" frame, triggering a \"STREAM_RESET\", and then to carry out another SDP exchange so the RTP sender **knows** that it should continue by sending the newest media frames on a new QUIC stream.\r\n\r\nDo you see another way to ensure that the Right Thing happens?\r\n\r\nDoes that make sense?",
              "createdAt": "2023-05-22T15:55:14Z",
              "updatedAt": "2023-05-22T15:56:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqAdZ",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:08:36Z",
          "updatedAt": "2023-05-22T17:08:37Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Yes, that sounds correct.",
              "createdAt": "2023-05-22T17:08:36Z",
              "updatedAt": "2023-05-22T17:08:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqGD6",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:22:02Z",
          "updatedAt": "2023-05-22T17:22:02Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> Are we mandating that RTP senders open a new stream and continue sending?\r\n\r\nYes, I think that is what we should do.\r\n\r\n> If we are, and a RTP receiver really has stopped caring about this RTP stream, how does it \"turn the RTP sender off\"?\r\n\r\nI don't think using STOP_SENDING is the right tool for this. Instead, it would probably require some signaling.\r\n\r\n> I think we're basically telling a RTP receiver that wants to \"skip forward to usable media frames\", to transmit a \"STOP_SENDING\" frame, triggering a \"STREAM_RESET\", and then to carry out another SDP exchange so the RTP sender **knows** that it should continue by sending the newest media frames on a new QUIC stream.\r\n>\r\n> Do you see another way to ensure that the Right Thing happens?\r\n\r\nI don't understand why we would carry out another SDP exchange here. The sender should take STOP_SENDING as a signal that the receiver is still interested in the media stream in general, but wants to start over with new media frames on new QUIC streams.",
              "createdAt": "2023-05-22T17:22:02Z",
              "updatedAt": "2023-05-22T17:22:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqK2b",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:32:42Z",
          "updatedAt": "2023-05-22T17:32:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we don't need any requirements language here, do we?",
              "createdAt": "2023-05-22T17:32:42Z",
              "updatedAt": "2023-05-22T17:32:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqLbd",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:33:19Z",
          "updatedAt": "2023-05-22T17:33:19Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Sounds good!",
              "createdAt": "2023-05-22T17:33:19Z",
              "updatedAt": "2023-05-22T17:33:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOFUmh7s5TMUqU",
      "title": "Fix reference to variable length integer encoding",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/97",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-16T13:36:39Z",
      "updatedAt": "2023-07-10T16:39:01Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/varint-reference",
      "headRefOid": "62f13d83c65a40377f6e525df79ae6e22d52d5a2",
      "closedAt": "2023-07-10T16:39:00Z",
      "mergedAt": "2023-07-10T16:39:00Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f09a2b523932612817fe08821d7cc09dd55e5d67"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "PR_kwDOFUmh7s5TMiWM",
      "title": "Clarify behaviour of STOP_SENDING and RESET_STREAM",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/98",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Second attempt to clarify the behaviour of STOP_SENDING and RESET_STREAM. I hope this is easier to understand than the current text and #96. It also adds subsections to add more structure to the whole subsection.",
      "createdAt": "2023-06-16T14:10:21Z",
      "updatedAt": "2023-07-10T16:29:21Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/stop-sending-2",
      "headRefOid": "4dd4ef703836c64cdfd2769db8c91be6e3111aaf",
      "closedAt": "2023-07-10T16:29:20Z",
      "mergedAt": "2023-07-10T16:29:20Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "800fd223a9fa4daa5048bfa3ae6c1ad45e1817c0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5auVUy",
          "commit": {
            "abbreviatedOid": "4dd4ef7"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I sent some comments via email, but I think the current text is close enough to merge for IETF 117.",
          "createdAt": "2023-07-10T13:29:31Z",
          "updatedAt": "2023-07-10T13:29:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOFUmh7s5UhgmP",
      "title": "Add green metadata to RTCP considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/99",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "fix #79 ",
      "createdAt": "2023-07-03T12:55:23Z",
      "updatedAt": "2023-07-03T12:55:24Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/79-green-metadata-rtcp",
      "headRefOid": "f610b7cf1e3510204321409a1dd6a857c7f5ef15",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 100,
      "id": "PR_kwDOFUmh7s5UiUz6",
      "title": "Add a list of considered header extensions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/100",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #95 ",
      "createdAt": "2023-07-03T15:09:41Z",
      "updatedAt": "2023-07-03T15:12:24Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/95-rtp-header-extensions",
      "headRefOid": "5ea9e83ed72c0b39b3719ea89dc5c15061692404",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 101,
      "id": "PR_kwDOFUmh7s5Uiejl",
      "title": "Add an appendix to list optional QUIC extensions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/101",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #92 ",
      "createdAt": "2023-07-03T15:33:40Z",
      "updatedAt": "2023-07-03T15:33:57Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/92-list-quic-extensions",
      "headRefOid": "2f25efbc08d5fbab70d1ad136b17392653ea332e",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 102,
      "id": "PR_kwDOFUmh7s5Ul4NN",
      "title": "Add considerations for aggregating frames",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/102",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #85 ",
      "createdAt": "2023-07-04T08:30:32Z",
      "updatedAt": "2023-07-10T16:29:52Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/85-frame-aggregation",
      "headRefOid": "117bf7d0ce7f21b576db5fd71a341bdcdd2ba858",
      "closedAt": "2023-07-10T16:29:51Z",
      "mergedAt": "2023-07-10T16:29:51Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5ee2df7bae1af902318cd3caf76db6b502ba820c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5aMVK8",
          "commit": {
            "abbreviatedOid": "117bf7d"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-04T16:32:10Z",
          "updatedAt": "2023-07-04T16:32:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOFUmh7s5VFxsc",
      "title": "Add @spencerdawkins as third author",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/105",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Just FYI, it's fine with me (and perhaps preferable for @adoba and @JonathanLennox, since WG chairs are responsible for assigning authors/editors to working group drafts) if you wait to merge this PR, and we present it as an open issue at IETF 117. \r\n\r\nBut at least it's in the repo now. \r\n\r\nclose #104 ",
      "createdAt": "2023-07-10T13:51:11Z",
      "updatedAt": "2023-07-10T19:45:59Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-104",
      "headRefOid": "e69f5ffdf1d45f579773262f335567f28085d6d9",
      "closedAt": "2023-07-10T19:42:08Z",
      "mergedAt": "2023-07-10T19:42:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "46c8dc0bfa9f60564a6717977c10c94687337ebd"
      },
      "comments": [
        {
          "author": "JonathanLennox",
          "authorAssociation": "NONE",
          "body": "As chair, I'm happy to have Spencer be a co-author of this draft.",
          "createdAt": "2023-07-10T17:43:12Z",
          "updatedAt": "2023-07-10T17:43:12Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks, @JonathanLennox , I submitted another version, including this PR :)",
          "createdAt": "2023-07-10T19:45:58Z",
          "updatedAt": "2023-07-10T19:45:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5av5er",
          "commit": {
            "abbreviatedOid": "e69f5ff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T16:28:57Z",
          "updatedAt": "2023-07-10T16:28:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOFUmh7s5VGzgr",
      "title": "Add proposal from e-mail discussion",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/106",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-10T16:37:26Z",
      "updatedAt": "2023-07-10T16:37:27Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "5ee2df7bae1af902318cd3caf76db6b502ba820c",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "open-new-stream-after-stop-sending",
      "headRefOid": "f9d8a6046e965418afa361e01b5c0c46a26883ba",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 108,
      "id": "PR_kwDOFUmh7s5Vzakn",
      "title": "Add references to close stream and enough drafts",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/108",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Add references and a paragraph to explain how the CLOSE_STREAM and ENOUGH frames could be used.\r\n\r\nClose #103 ",
      "createdAt": "2023-07-18T16:07:30Z",
      "updatedAt": "2023-07-18T16:07:31Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/103-close-stream-enough",
      "headRefOid": "377b9eaa8d62095e6f8da9922b2026712d340930",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 109,
      "id": "PR_kwDOFUmh7s5V7Z0F",
      "title": "Add motivations section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/109",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "@mengelbart and @gchandok - I'm sure I'm leaving motivations out, so I'd appreciate your comments on this PR even more than usual!\r\n\r\ncloses #77 ",
      "createdAt": "2023-07-19T19:37:05Z",
      "updatedAt": "2023-07-23T00:20:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-77",
      "headRefOid": "c68d2c2a006ab5ea22b534cf86209c55856ea827",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 110,
      "id": "PR_kwDOFUmh7s5V7eyS",
      "title": "Clean up \"RTP-over-QUIC\" terminology",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/110",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "I also added \"(RoQ)\" to the document title, to make this easier to spot for readers. \r\n\r\nfixes #107 ",
      "createdAt": "2023-07-19T19:53:33Z",
      "updatedAt": "2023-07-20T07:33:23Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-107",
      "headRefOid": "72e7c42677ce00d6fddf488792af04a96b976d59",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5btYHc",
          "commit": {
            "abbreviatedOid": "72e7c42"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-20T07:33:23Z",
          "updatedAt": "2023-07-20T07:33:23Z",
          "comments": []
        }
      ]
    }
  ]
}